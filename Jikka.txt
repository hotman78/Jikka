-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A transpiler from Python to C++ for competitive programming
--   
--   Please see the README on GitHub at
--   <a>https://github.com/kmyk/Jikka</a>
@package Jikka
@version 5.0.6.0


-- | <a>Expr</a> module has the basic data types for C++ language. The data
--   types are intended to use for the code generation.
module Jikka.CPlusPlus.Language.Expr
newtype VarName
VarName :: String -> VarName
[unVarName] :: VarName -> String
newtype FunName
FunName :: String -> FunName
[unFunName] :: FunName -> String
data Type
TyAuto :: Type
TyVoid :: Type
TyBool :: Type
TyInt :: Type
TyInt32 :: Type
TyInt64 :: Type
TyTuple :: [Type] -> Type
TyVector :: Type -> Type
TyArray :: Type -> Integer -> Type
TyString :: Type
TyFunction :: Type -> [Type] -> Type

-- | for template parameters
TyIntValue :: Integer -> Type
data Literal
LitInt32 :: Integer -> Literal
LitInt64 :: Integer -> Literal
LitBool :: Bool -> Literal
LitChar :: Char -> Literal
LitString :: String -> Literal
data Function
Callable :: Expr -> Function
Function :: FunName -> [Type] -> Function
Method :: Expr -> FunName -> Function
data UnaryOp
IntNop :: UnaryOp
Negate :: UnaryOp
BitNot :: UnaryOp
Not :: UnaryOp
data BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Mul :: BinaryOp
Div :: BinaryOp
Mod :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
BitLeftShift :: BinaryOp
BitRightShift :: BinaryOp
And :: BinaryOp
Or :: BinaryOp
LessThan :: BinaryOp
LessEqual :: BinaryOp
GreaterThan :: BinaryOp
GreaterEqual :: BinaryOp
Equal :: BinaryOp
NotEqual :: BinaryOp
data AssignOp
SimpleAssign :: AssignOp
AddAssign :: AssignOp
SubAssign :: AssignOp
MulAssign :: AssignOp
DivAssign :: AssignOp
ModAssign :: AssignOp
BitLeftShiftAssign :: AssignOp
BitRightShiftAssign :: AssignOp
BitAndAssign :: AssignOp
BitOrAssign :: AssignOp
BitXorAssign :: AssignOp
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr
UnOp :: UnaryOp -> Expr -> Expr
BinOp :: BinaryOp -> Expr -> Expr -> Expr
Cond :: Expr -> Expr -> Expr -> Expr
Lam :: [(Type, VarName)] -> Type -> [Statement] -> Expr
Call :: Function -> [Expr] -> Expr
VecExt :: Type -> [Expr] -> Expr
At :: Expr -> Expr -> Expr
Cast :: Type -> Expr -> Expr
data LeftExpr
LeftVar :: VarName -> LeftExpr
LeftAt :: LeftExpr -> Expr -> LeftExpr

-- | <pre>
--   std::get<a>n</a>
--   </pre>
LeftGet :: Integer -> LeftExpr -> LeftExpr
data AssignExpr
AssignExpr :: AssignOp -> LeftExpr -> Expr -> AssignExpr
AssignIncr :: LeftExpr -> AssignExpr
AssignDecr :: LeftExpr -> AssignExpr
data Statement
ExprStatement :: Expr -> Statement
Block :: [Statement] -> Statement
If :: Expr -> [Statement] -> Maybe [Statement] -> Statement
For :: Type -> VarName -> Expr -> Expr -> AssignExpr -> [Statement] -> Statement
ForEach :: Type -> VarName -> Expr -> [Statement] -> Statement
While :: Expr -> [Statement] -> Statement
Declare :: Type -> VarName -> Maybe Expr -> Statement
Assign :: AssignExpr -> Statement
Assert :: Expr -> Statement
Return :: Expr -> Statement
data ToplevelStatement
VarDef :: Type -> VarName -> Expr -> ToplevelStatement
FunDef :: Type -> VarName -> [(Type, VarName)] -> [Statement] -> ToplevelStatement
newtype Program
Program :: [ToplevelStatement] -> Program
[decls] :: Program -> [ToplevelStatement]
instance Data.String.IsString Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.VarName
instance Data.String.IsString Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Program

module Jikka.CPlusPlus.Language.Util
fromLeftExpr :: LeftExpr -> Expr


-- | <a>Alpha</a> provides a monad to run alpha-conversion. This monad has
--   only a feature to make unique numbers.
module Jikka.Common.Alpha
class Monad m => MonadAlpha m
nextCounter :: MonadAlpha m => m Int
newtype AlphaT m a
AlphaT :: (Int -> m (a, Int)) -> AlphaT m a
[runAlphaT] :: AlphaT m a -> Int -> m (a, Int)
liftCatch :: Catch e m (a, Int) -> Catch e (AlphaT m) a
evalAlphaT :: Functor m => AlphaT m a -> Int -> m a
instance GHC.Base.Monad m => Jikka.Common.Alpha.MonadAlpha (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.Trans.Class.MonadTrans Jikka.Common.Alpha.AlphaT
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Jikka.Common.Alpha.AlphaT m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Except.ExceptT e m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Reader.ReaderT r m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.State.Strict.StateT s m)
instance (Jikka.Common.Alpha.MonadAlpha m, GHC.Base.Monoid w) => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Writer.Strict.WriterT w m)

module Jikka.Common.Combinatorics
fact :: Integral a => a -> a
choose :: Integral a => a -> a -> a
permute :: Integral a => a -> a -> a
multichoose :: Integral a => a -> a -> a

module Jikka.Common.Format.AutoIndent
indent :: String
dedent :: String
makeIndentFromMarkers :: Int -> [String] -> [String]
makeIndentFromBraces :: Int -> [String] -> [String]
insertIndentDedentFromBraces :: [String] -> [String]


-- | <a>Format</a> module converts the AST for C++ to the plain source
--   code.
module Jikka.CPlusPlus.Format
run :: Applicative m => Program -> m Text
run' :: Program -> String
type Code = String
formatExpr :: Expr -> (Code, Prec)
formatType :: Type -> Code
instance GHC.Read.Read Jikka.CPlusPlus.Format.Prec
instance GHC.Show.Show Jikka.CPlusPlus.Format.Prec
instance GHC.Classes.Ord Jikka.CPlusPlus.Format.Prec
instance GHC.Classes.Eq Jikka.CPlusPlus.Format.Prec
instance GHC.Read.Read Jikka.CPlusPlus.Format.Assoc
instance GHC.Show.Show Jikka.CPlusPlus.Format.Assoc
instance GHC.Classes.Ord Jikka.CPlusPlus.Format.Assoc
instance GHC.Classes.Eq Jikka.CPlusPlus.Format.Assoc

module Jikka.Common.Format.Color
data ColorFlag
EnableColor :: ColorFlag
DisableColor :: ColorFlag
withColor :: ColorFlag -> Color -> String -> String
withBold :: ColorFlag -> String -> String
hGetColorFlag :: Handle -> IO ColorFlag

-- | ANSI's eight standard colors. They come in two intensities, which are
--   controlled by <a>ColorIntensity</a>. Many terminals allow the colors
--   of the standard palette to be customised, so that, for example,
--   <tt>setSGR [ SetColor Foreground Vivid Green ]</tt> may not result in
--   bright green characters.
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color
instance GHC.Read.Read Jikka.Common.Format.Color.ColorFlag
instance GHC.Show.Show Jikka.Common.Format.Color.ColorFlag
instance GHC.Classes.Ord Jikka.Common.Format.Color.ColorFlag
instance GHC.Classes.Eq Jikka.Common.Format.Color.ColorFlag

module Jikka.Common.Format.Show
run :: Show program => program -> Either String Text

module Jikka.Common.Graph
type Graph = Vector [Int]
makeReversedDigraph :: Graph -> Graph
makeInducedDigraph :: Graph -> Vector Int -> Graph

-- | <a>decomposeToStronglyConnectedComponents</a> does SCC in &lt;math&gt;
--   using Kosaraju's algorithm. It takes a digraph &lt;math&gt; as an
--   adjacent list &lt;math&gt;, and returns an mapping &lt;math&gt; for
--   the SCC DAG &lt;math&gt;. The indices of vertices of the SCC DAG are
--   topologically sorted.
decomposeToStronglyConnectedComponents :: Graph -> Vector Int

-- | <a>topologicalSort</a> does topological sort in &lt;math&gt; using
--   Tarjan's algorithm. The input is an adjacent list of a DAG.
topologicalSort :: Graph -> Vector Int

module Jikka.Common.IO
hTakeWhile :: Handle -> (Char -> Bool) -> IO String
hGetWord :: Handle -> IO String
getWord :: IO String

module Jikka.Common.Location

-- | <a>Loc</a> represents a location of something in the users' source
--   code. <a>line</a> and <a>column</a> is 1-based.
data Loc
Loc :: !Int -> !Int -> !Int -> Loc
[line] :: Loc -> !Int
[column] :: Loc -> !Int
[width] :: Loc -> !Int
data WithLoc a
WithLoc :: !Loc -> !a -> WithLoc a
[loc] :: WithLoc a -> !Loc
[value] :: WithLoc a -> !a
data WithLoc' a
WithLoc' :: !Maybe Loc -> !a -> WithLoc' a
[loc'] :: WithLoc' a -> !Maybe Loc
[value'] :: WithLoc' a -> !a
withoutLoc :: a -> WithLoc' a
instance GHC.Read.Read Jikka.Common.Location.Loc
instance GHC.Show.Show Jikka.Common.Location.Loc
instance GHC.Classes.Ord Jikka.Common.Location.Loc
instance GHC.Classes.Eq Jikka.Common.Location.Loc
instance GHC.Base.Functor Jikka.Common.Location.WithLoc
instance GHC.Read.Read a => GHC.Read.Read (Jikka.Common.Location.WithLoc a)
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Location.WithLoc a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Location.WithLoc a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Location.WithLoc a)
instance GHC.Base.Functor Jikka.Common.Location.WithLoc'
instance GHC.Read.Read a => GHC.Read.Read (Jikka.Common.Location.WithLoc' a)
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Location.WithLoc' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Location.WithLoc' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Location.WithLoc' a)
instance Data.String.IsString a => Data.String.IsString (Jikka.Common.Location.WithLoc' a)

module Jikka.Common.Format.Location
prettyLoc :: Loc -> String
prettyLocWithText :: ColorFlag -> Text -> Loc -> [String]


module Jikka.Common.Error
data Responsibility
UserMistake :: Responsibility
ImplementationBug :: Responsibility
data ErrorGroup

-- | It's impossible to split the given source text into tokens.
LexicalError :: ErrorGroup

-- | It's impossible to construct AST from tokens.
SyntaxError :: ErrorGroup

-- | There are undefined variables or functions in AST.
SymbolError :: ErrorGroup

-- | It's impossible reconstruct types for AST.
TypeError :: ErrorGroup

-- | other semantic erros
SemanticError :: ErrorGroup

-- | User's program are not ready to evaluate.
EvaluationError :: ErrorGroup

-- | User's program failed while running.
RuntimeError :: ErrorGroup

-- | User's program violates its assertion.
AssertionError :: ErrorGroup

-- | The given command line arguments are not acceptable.
CommandLineError :: ErrorGroup

-- | User's program was correctly running but wrong input text is given.
WrongInputError :: ErrorGroup

-- | It's an bug of implementation.
InternalError :: ErrorGroup
data Error
Error :: String -> Error
ErrorAppend :: Error -> Error -> Error
WithGroup :: ErrorGroup -> Error -> Error
WithWrapped :: String -> Error -> Error
WithLocation :: Loc -> Error -> Error
WithResponsibility :: Responsibility -> Error -> Error
wrapError :: MonadError e m => (e -> e) -> m a -> m a
wrapError' :: MonadError Error m => String -> m a -> m a
wrapAt :: MonadError Error m => Loc -> m a -> m a
maybeToError :: MonadError a m => a -> Maybe b -> m b
eitherToError :: MonadError a m => Either a b -> m b

-- | <a>catchError</a>` is the inverse of <tt>liftError</tt>.
catchError' :: MonadError e m => m a -> m (Either e a)
reportErrors :: MonadError Error m => [Either Error a] -> m [a]
reportErrors2 :: MonadError Error m => Either Error a -> Either Error b -> m (a, b)
reportErrors3 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> m (a, b, c)
reportErrors4 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> Either Error d -> m (a, b, c, d)
reportErrors5 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> Either Error d -> Either Error e -> m (a, b, c, d, e)
lexicalError :: String -> Error
lexicalErrorAt :: Loc -> String -> Error
syntaxError :: String -> Error
syntaxErrorAt :: Loc -> String -> Error
symbolError :: String -> Error
symbolErrorAt :: Loc -> String -> Error
typeError :: String -> Error
semanticError :: String -> Error
evaluationError :: String -> Error
runtimeError :: String -> Error
assertionError :: String -> Error
commandLineError :: String -> Error
wrongInputError :: String -> Error
internalError :: String -> Error
throwLexicalError :: MonadError Error m => String -> m a
throwLexicalErrorAt :: MonadError Error m => Loc -> String -> m a
throwSyntaxError :: MonadError Error m => String -> m a
throwSyntaxErrorAt :: MonadError Error m => Loc -> String -> m a
throwSymbolError :: MonadError Error m => String -> m a
throwSymbolErrorAt :: MonadError Error m => Loc -> String -> m a
throwTypeError :: MonadError Error m => String -> m a
throwTypeErrorAt :: MonadError Error m => Loc -> String -> m a
throwSemanticError :: MonadError Error m => String -> m a
throwSemanticErrorAt :: MonadError Error m => Loc -> String -> m a
throwEvaluationError :: MonadError Error m => String -> m a
throwRuntimeError :: MonadError Error m => String -> m a
throwAssertionError :: MonadError Error m => String -> m a
throwCommandLineError :: MonadError Error m => String -> m a
throwWrongInputError :: MonadError Error m => String -> m a
throwInternalError :: MonadError Error m => String -> m a
bug :: String -> a
todo :: String -> a
instance GHC.Read.Read Jikka.Common.Error.Responsibility
instance GHC.Show.Show Jikka.Common.Error.Responsibility
instance GHC.Classes.Ord Jikka.Common.Error.Responsibility
instance GHC.Classes.Eq Jikka.Common.Error.Responsibility
instance GHC.Read.Read Jikka.Common.Error.ErrorGroup
instance GHC.Show.Show Jikka.Common.Error.ErrorGroup
instance GHC.Classes.Ord Jikka.Common.Error.ErrorGroup
instance GHC.Classes.Eq Jikka.Common.Error.ErrorGroup
instance GHC.Read.Read Jikka.Common.Error.Error
instance GHC.Show.Show Jikka.Common.Error.Error
instance GHC.Classes.Ord Jikka.Common.Error.Error
instance GHC.Classes.Eq Jikka.Common.Error.Error
instance GHC.Base.Semigroup Jikka.Common.Error.Error

module Jikka.Common.Format.Error
prettyError :: ColorFlag -> Error -> [String]
prettyErrorWithText :: ColorFlag -> Text -> Error -> [String]
hPrintError :: Handle -> Error -> IO ()
hPrintErrorWithText :: Handle -> Text -> Error -> IO ()

module Jikka.Common.Matrix

-- | <a>Matrix</a> is data for matrices. It is guaranteed that internal
--   arrays are not jagged arrays.
data Matrix a
unMatrix :: Matrix a -> Vector (Vector a)
makeMatrix :: Vector (Vector a) -> Maybe (Matrix a)
makeMatrix' :: Vector (Vector a) -> Matrix a

-- | <a>matsize</a> computes the size of a matrix.
matsize :: Matrix a -> (Int, Int)

-- | <a>matsize</a>` computes the size of a matrix. This assumes inputs are
--   matrices (<a>matcheck</a>).
matsize' :: Vector (Vector a) -> (Int, Int)

-- | <a>matcheck</a> checks a given vector of vectors is a matrix. That is,
--   this returns <a>False</a> for jagged arrays.
matcheck :: Vector (Vector a) -> Bool
matzero :: Num a => Int -> Matrix a
matone :: Num a => Int -> Matrix a

-- | <a>matadd</a> calculates the addition &lt;math&gt; of two matrices
--   &lt;math&gt;. This assumes sizes of inputs match.
matadd :: Num a => Matrix a -> Matrix a -> Matrix a

-- | <a>matmul</a> calculates the multiplication &lt;math&gt;of two
--   matrices &lt;math&gt;. This assumes sizes of inputs match.
matmul :: Num a => Matrix a -> Matrix a -> Matrix a

-- | <a>matap</a> calculates the multiplication &lt;math&gt; of a matrix
--   &lt;math&gt; and a vector &lt;math&gt;. This assumes sizes of inputs
--   match.
matap :: Num a => Matrix a -> Vector a -> Vector a
matscalar :: Num a => a -> Matrix a -> Matrix a

-- | <a>matpow</a> calculates the power &lt;math&gt; of a matrix
--   &lt;math&gt; and a natural number &lt;math&gt;. This assumes inputs
--   are square matrices. This fails for &lt;math&gt;.
matpow :: (Show a, Num a) => Matrix a -> Integer -> Matrix a
instance GHC.Base.Functor Jikka.Common.Matrix.Matrix
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Matrix.Matrix a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Matrix.Matrix a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Matrix.Matrix a)

module Jikka.Common.ModInt
data ModInt
toModInt :: Integer -> Integer -> ModInt
fromModInt :: ModInt -> Integer
moduloOfModInt :: ModInt -> Maybe Integer
instance GHC.Show.Show Jikka.Common.ModInt.ModInt
instance GHC.Read.Read Jikka.Common.ModInt.ModInt
instance GHC.Classes.Ord Jikka.Common.ModInt.ModInt
instance GHC.Classes.Eq Jikka.Common.ModInt.ModInt
instance GHC.Num.Num Jikka.Common.ModInt.ModInt

module Jikka.Common.Parse.JoinLines
joinLinesWithParens :: forall m a. (MonadError Error m, Show a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> [WithLoc a] -> m [WithLoc a]
removeEmptyLines :: forall a. (a -> Bool) -> [WithLoc a] -> [WithLoc a]

module Jikka.Common.Parse.OffsideRule

-- | <a>insertIndents</a> inserts <tt>INDENT</tt> and <tt>DEDENT</tt>
--   tokens with Python's way
--   (<a>https://docs.python.org/3/reference/lexical_analysis.html#indentation</a>).
--   The <a>column</a> of <a>Loc</a> must be 1-based. This doen't use
--   physical <a>line</a> of <a>Loc</a> because logical lines are used for
--   indentation.
insertIndents :: forall m a. (MonadError Error m, Show a) => a -> a -> (a -> Bool) -> [WithLoc a] -> m [WithLoc a]

module Jikka.Common.Parse.Read
run :: Read program => FilePath -> Text -> Either String program

module Jikka.Common.Parse.ShuntingYard
run :: forall m op expr. MonadError Error m => (op -> m BinOpInfo) -> (WithLoc op -> WithLoc expr -> WithLoc expr -> WithLoc expr) -> (WithLoc expr, [(WithLoc op, WithLoc expr)]) -> m (WithLoc expr)
type Prec = Int
data Fixity
Leftfix :: Fixity
Rightfix :: Fixity
Nonfix :: Fixity
data BinOpInfo
BinOpInfo :: Fixity -> Prec -> BinOpInfo
instance GHC.Read.Read Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Show.Show Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Enum.Bounded Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Enum.Enum Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Classes.Ord Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Classes.Eq Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Read.Read Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Show.Show Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Classes.Ord Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Classes.Eq Jikka.Common.Parse.ShuntingYard.BinOpInfo


-- | <a>Expr</a> module has the basic data types for our core language.
--   They are similar to the GHC Core language.
module Jikka.Core.Language.Expr
newtype VarName
VarName :: String -> VarName
unVarName :: VarName -> String
newtype TypeName
TypeName :: String -> TypeName
unTypeName :: TypeName -> String

-- | <a>Type</a> represents the types of our core language. This is similar
--   to the <a>Type</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>type-type</a>.
--   
--   &lt;math&gt;
data Type
VarTy :: TypeName -> Type
IntTy :: Type
BoolTy :: Type
ListTy :: Type -> Type
TupleTy :: [Type] -> Type

-- | The functions are not curried. TODO: currying?
FunTy :: [Type] -> Type -> Type

-- | TODO: What is the difference between <a>Literal</a> and
--   <a>Builtin</a>?
data Builtin

-- | &lt;math&gt;
Negate :: Builtin

-- | &lt;math&gt;
Plus :: Builtin

-- | &lt;math&gt;
Minus :: Builtin

-- | &lt;math&gt;
Mult :: Builtin

-- | &lt;math&gt;
FloorDiv :: Builtin

-- | &lt;math&gt;
FloorMod :: Builtin

-- | &lt;math&gt;
CeilDiv :: Builtin

-- | &lt;math&gt;
CeilMod :: Builtin

-- | &lt;math&gt;
Pow :: Builtin

-- | natural induction &lt;math&gt;
NatInd :: Type -> Builtin

-- | &lt;math&gt;
Abs :: Builtin

-- | &lt;math&gt;
Gcd :: Builtin

-- | &lt;math&gt;
Lcm :: Builtin

-- | &lt;math&gt;
Min2 :: Type -> Builtin

-- | &lt;math&gt;
Max2 :: Type -> Builtin

-- | &lt;math&gt;
Not :: Builtin

-- | &lt;math&gt;
And :: Builtin

-- | &lt;math&gt;
Or :: Builtin

-- | &lt;math&gt;
Implies :: Builtin

-- | &lt;math&gt;
If :: Type -> Builtin

-- | &lt;math&gt;
BitNot :: Builtin

-- | &lt;math&gt;
BitAnd :: Builtin

-- | &lt;math&gt;
BitOr :: Builtin

-- | &lt;math&gt;
BitXor :: Builtin

-- | &lt;math&gt;
BitLeftShift :: Builtin

-- | &lt;math&gt;
BitRightShift :: Builtin

-- | matrix application &lt;math&gt;
MatAp :: Int -> Int -> Builtin

-- | zero matrix &lt;math&gt;
MatZero :: Int -> Builtin

-- | unit matrix &lt;math&gt;
MatOne :: Int -> Builtin

-- | matrix addition &lt;math&gt;
MatAdd :: Int -> Int -> Builtin

-- | matrix multiplication &lt;math&gt;
MatMul :: Int -> Int -> Int -> Builtin

-- | matrix power &lt;math&gt;
MatPow :: Int -> Builtin

-- | &lt;math&gt;
ModInv :: Builtin

-- | &lt;math&gt;
ModPow :: Builtin

-- | matrix application &lt;math&gt;
ModMatAp :: Int -> Int -> Builtin

-- | matrix addition &lt;math&gt;
ModMatAdd :: Int -> Int -> Builtin

-- | matrix multiplication &lt;math&gt;
ModMatMul :: Int -> Int -> Int -> Builtin

-- | matrix power &lt;math&gt;
ModMatPow :: Int -> Builtin

-- | &lt;math&gt;
Cons :: Type -> Builtin

-- | &lt;math&gt;
Foldl :: Type -> Type -> Builtin

-- | &lt;math&gt;
Scanl :: Type -> Type -> Builtin

-- | &lt;math&gt;
Len :: Type -> Builtin

-- | &lt;math&gt;
Tabulate :: Type -> Builtin

-- | &lt;math&gt;
Map :: Type -> Type -> Builtin

-- | &lt;math&gt;
Filter :: Type -> Builtin

-- | &lt;math&gt;
At :: Type -> Builtin

-- | &lt;math&gt;
SetAt :: Type -> Builtin

-- | &lt;math&gt;
Elem :: Type -> Builtin

-- | &lt;math&gt;
Sum :: Builtin

-- | &lt;math&gt;
Product :: Builtin

-- | &lt;math&gt;
Min1 :: Type -> Builtin

-- | &lt;math&gt;
Max1 :: Type -> Builtin

-- | &lt;math&gt;
ArgMin :: Type -> Builtin

-- | &lt;math&gt;
ArgMax :: Type -> Builtin

-- | &lt;math&gt;
All :: Builtin

-- | &lt;math&gt;
Any :: Builtin

-- | &lt;math&gt;
Sorted :: Type -> Builtin

-- | &lt;math&gt;
List :: Type -> Builtin

-- | &lt;math&gt;
Reversed :: Type -> Builtin

-- | &lt;math&gt;1
Range1 :: Builtin

-- | &lt;math&gt;1
Range2 :: Builtin

-- | &lt;math&gt;1
Range3 :: Builtin

-- | &lt;math&gt;
Tuple :: [Type] -> Builtin

-- | &lt;math&gt;
Proj :: [Type] -> Int -> Builtin

-- | &lt;math&gt;
LessThan :: Type -> Builtin

-- | &lt;math&gt;
LessEqual :: Type -> Builtin

-- | &lt;math&gt;
GreaterThan :: Type -> Builtin

-- | &lt;math&gt;
GreaterEqual :: Type -> Builtin

-- | &lt;math&gt;
Equal :: Type -> Builtin

-- | &lt;math&gt;
NotEqual :: Type -> Builtin

-- | &lt;math&gt;
Fact :: Builtin

-- | &lt;math&gt;
Choose :: Builtin

-- | &lt;math&gt;
Permute :: Builtin

-- | &lt;math&gt;
MultiChoose :: Builtin
data Literal
LitBuiltin :: Builtin -> Literal

-- | &lt;math&gt;
LitInt :: Integer -> Literal

-- | &lt;math&gt;
LitBool :: Bool -> Literal

-- | &lt;math&gt;
LitNil :: Type -> Literal

-- | <a>Expr</a> represents the exprs of our core language. This is similar
--   to the <a>Expr</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>core-syn-type</a>.
--   
--   &lt;math&gt;
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr

-- | The functions are not curried.
App :: Expr -> [Expr] -> Expr

-- | The lambdas are also not curried.
Lam :: [(VarName, Type)] -> Expr -> Expr

-- | This "let" is not recursive.
Let :: VarName -> Type -> Expr -> Expr -> Expr
pattern Fun1Ty :: Type -> Type
pattern Fun2Ty :: Type -> Type
pattern Fun3Ty :: Type -> Type
pattern FunLTy :: Type -> Type
vectorTy :: Int -> Type
matrixTy :: Int -> Int -> Type
pattern LitInt' :: Integer -> Expr
pattern Lit0 :: Expr
pattern Lit1 :: Expr
pattern Lit2 :: Expr
pattern LitMinus1 :: Expr
pattern LitBool' :: Bool -> Expr
pattern LitTrue :: Expr
pattern LitFalse :: Expr
pattern Builtin :: Builtin -> Expr
pattern AppBuiltin :: Builtin -> [Expr] -> Expr
pattern Lam1 :: VarName -> Type -> Expr -> Expr
pattern Lam2 :: VarName -> Type -> VarName -> Type -> Expr -> Expr
pattern Lam3 :: VarName -> Type -> VarName -> Type -> VarName -> Type -> Expr -> Expr
pattern LamId :: VarName -> Type -> Expr

-- | <a>ToplevelExpr</a> is the toplevel exprs. In our core, "let rec" is
--   allowed only on the toplevel.
--   
--   &lt;math&gt;
data ToplevelExpr
ResultExpr :: Expr -> ToplevelExpr
ToplevelLet :: VarName -> Type -> Expr -> ToplevelExpr -> ToplevelExpr
ToplevelLetRec :: VarName -> [(VarName, Type)] -> Type -> Expr -> ToplevelExpr -> ToplevelExpr
type Program = ToplevelExpr
instance Data.String.IsString Jikka.Core.Language.Expr.VarName
instance GHC.Read.Read Jikka.Core.Language.Expr.VarName
instance GHC.Show.Show Jikka.Core.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.Core.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.Core.Language.Expr.VarName
instance Data.String.IsString Jikka.Core.Language.Expr.TypeName
instance GHC.Read.Read Jikka.Core.Language.Expr.TypeName
instance GHC.Show.Show Jikka.Core.Language.Expr.TypeName
instance GHC.Classes.Ord Jikka.Core.Language.Expr.TypeName
instance GHC.Classes.Eq Jikka.Core.Language.Expr.TypeName
instance GHC.Read.Read Jikka.Core.Language.Expr.Type
instance GHC.Show.Show Jikka.Core.Language.Expr.Type
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Type
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Type
instance GHC.Read.Read Jikka.Core.Language.Expr.Builtin
instance GHC.Show.Show Jikka.Core.Language.Expr.Builtin
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Builtin
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Builtin
instance GHC.Read.Read Jikka.Core.Language.Expr.Literal
instance GHC.Show.Show Jikka.Core.Language.Expr.Literal
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Literal
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Literal
instance GHC.Read.Read Jikka.Core.Language.Expr.Expr
instance GHC.Show.Show Jikka.Core.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Expr
instance GHC.Read.Read Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Show.Show Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Classes.Ord Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Classes.Eq Jikka.Core.Language.Expr.ToplevelExpr


-- | <a>BuiltinPatterns</a> provides pattern synonyms for applications of
--   <a>Builtin</a> functions. For example, provide a pattern <tt>Sum'
--   e</tt> which is interpreted as <tt>AppBuiltin Sum [e]</tt>, or the
--   same thing, <tt>App (Lit (LitBuiltin Sum)) [e]</tt>.
module Jikka.Core.Language.BuiltinPatterns
pattern Negate' :: Expr -> Expr
pattern Plus' :: Expr -> Expr -> Expr
pattern Minus' :: Expr -> Expr -> Expr
pattern Mult' :: Expr -> Expr -> Expr
pattern FloorDiv' :: Expr -> Expr -> Expr
pattern FloorMod' :: Expr -> Expr -> Expr
pattern CeilDiv' :: Expr -> Expr -> Expr
pattern CeilMod' :: Expr -> Expr -> Expr
pattern Pow' :: Expr -> Expr -> Expr
pattern NatInd' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Abs' :: Expr -> Expr
pattern Gcd' :: Expr -> Expr -> Expr
pattern Lcm' :: Expr -> Expr -> Expr
pattern Min2' :: Type -> Expr -> Expr -> Expr
pattern Max2' :: Type -> Expr -> Expr -> Expr
pattern Not' :: Expr -> Expr
pattern And' :: Expr -> Expr -> Expr
pattern Or' :: Expr -> Expr -> Expr
pattern Implies' :: Expr -> Expr -> Expr
pattern If' :: Type -> Expr -> Expr -> Expr -> Expr
pattern BitNot' :: Expr -> Expr
pattern BitAnd' :: Expr -> Expr -> Expr
pattern BitOr' :: Expr -> Expr -> Expr
pattern BitXor' :: Expr -> Expr -> Expr
pattern BitLeftShift' :: Expr -> Expr -> Expr
pattern BitRightShift' :: Expr -> Expr -> Expr
pattern MatAp' :: Int -> Int -> Expr -> Expr -> Expr
pattern MatZero' :: Int -> Expr
pattern MatOne' :: Int -> Expr
pattern MatAdd' :: Int -> Int -> Expr -> Expr -> Expr
pattern MatMul' :: Int -> Int -> Int -> Expr -> Expr -> Expr
pattern MatPow' :: Int -> Expr -> Expr -> Expr
pattern ModInv' :: Expr -> Expr -> Expr
pattern ModPow' :: Expr -> Expr -> Expr -> Expr
pattern ModMatAp' :: Int -> Int -> Expr -> Expr -> Expr -> Expr
pattern ModMatAdd' :: Int -> Int -> Expr -> Expr -> Expr -> Expr
pattern ModMatMul' :: Int -> Int -> Int -> Expr -> Expr -> Expr -> Expr
pattern ModMatPow' :: Int -> Expr -> Expr -> Expr -> Expr
pattern Cons' :: Type -> Expr -> Expr -> Expr
pattern Foldl' :: Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern Scanl' :: Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern Len' :: Type -> Expr -> Expr
pattern Tabulate' :: Type -> Expr -> Expr -> Expr
pattern Map' :: Type -> Type -> Expr -> Expr -> Expr
pattern Filter' :: Type -> Expr -> Expr -> Expr
pattern At' :: Type -> Expr -> Expr -> Expr
pattern SetAt' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Elem' :: Type -> Expr -> Expr -> Expr
pattern Sum' :: Expr -> Expr
pattern Product' :: Expr -> Expr
pattern Min1' :: Type -> Expr -> Expr
pattern Max1' :: Type -> Expr -> Expr
pattern ArgMin' :: Type -> Expr -> Expr
pattern ArgMax' :: Type -> Expr -> Expr
pattern All' :: Expr -> Expr
pattern Any' :: Expr -> Expr
pattern Sorted' :: Type -> Expr -> Expr
pattern List' :: Type -> Expr -> Expr
pattern Reversed' :: Type -> Expr -> Expr
pattern Range1' :: Expr -> Expr
pattern Range2' :: Expr -> Expr -> Expr
pattern Range3' :: Expr -> Expr -> Expr -> Expr
pattern Tuple' :: [Type] -> [Expr] -> Expr
pattern Proj' :: [Type] -> Int -> Expr -> Expr
pattern LessThan' :: Type -> Expr -> Expr -> Expr
pattern LessEqual' :: Type -> Expr -> Expr -> Expr
pattern GreaterThan' :: Type -> Expr -> Expr -> Expr
pattern GreaterEqual' :: Type -> Expr -> Expr -> Expr
pattern Equal' :: Type -> Expr -> Expr -> Expr
pattern NotEqual' :: Type -> Expr -> Expr -> Expr
pattern Fact' :: Expr -> Expr
pattern Choose' :: Expr -> Expr -> Expr
pattern Permute' :: Expr -> Expr -> Expr
pattern MultiChoose' :: Expr -> Expr -> Expr


module Jikka.Core.Format
run :: Applicative m => Program -> m Text
run' :: Program -> String
formatBuiltinIsolated :: Builtin -> String
formatBuiltin :: Builtin -> [Expr] -> String
formatType :: Type -> String
formatExpr :: Expr -> String
instance GHC.Read.Read Jikka.Core.Format.Builtin'
instance GHC.Show.Show Jikka.Core.Format.Builtin'
instance GHC.Classes.Ord Jikka.Core.Format.Builtin'
instance GHC.Classes.Eq Jikka.Core.Format.Builtin'


-- | <a>Alpha</a> renames variables in exprs to avoid name conflictions,
--   even if the scopes of two variables are distinct.
module Jikka.Core.Convert.Alpha
rename :: MonadAlpha m => VarName -> m VarName
runExpr :: (MonadAlpha m, MonadError Error m) => [(VarName, VarName)] -> Expr -> m Expr
runToplevelExpr :: (MonadAlpha m, MonadError Error m) => [(VarName, VarName)] -> ToplevelExpr -> m ToplevelExpr
runProgram :: (MonadAlpha m, MonadError Error m) => Program -> m Program
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Core.Language.Runtime
floorDiv :: MonadError Error m => Integer -> Integer -> m Integer
floorMod :: MonadError Error m => Integer -> Integer -> m Integer
ceilDiv :: MonadError Error m => Integer -> Integer -> m Integer
ceilMod :: MonadError Error m => Integer -> Integer -> m Integer
minimumEither :: (MonadError Error m, Ord a) => [a] -> m a
maximumEither :: (MonadError Error m, Ord a) => [a] -> m a
argminEither :: (MonadError Error m, Ord a) => [a] -> m Integer
argmaxEither :: (MonadError Error m, Ord a) => [a] -> m Integer
modinv :: MonadError Error m => Integer -> Integer -> m Integer
modpow :: MonadError Error m => Integer -> Integer -> Integer -> m Integer
fact :: MonadError Error m => Integer -> m Integer
choose :: MonadError Error m => Integer -> Integer -> m Integer
permute :: MonadError Error m => Integer -> Integer -> m Integer
multichoose :: MonadError Error m => Integer -> Integer -> m Integer

module Jikka.Core.Language.TypeCheck
builtinToType :: Builtin -> Type
literalToType :: Literal -> Type
type TypeEnv = [(VarName, Type)]

-- | <a>typecheckExpr</a> checks that the given <a>Expr</a> has the correct
--   types.
typecheckExpr :: MonadError Error m => TypeEnv -> Expr -> m Type
typecheckToplevelExpr :: MonadError Error m => TypeEnv -> ToplevelExpr -> m Type
typecheckProgram :: MonadError Error m => Program -> m Type


-- | <a>Lint</a> module checks the invariants of data types. Mainly, this
--   checks types of <a>Expr</a>.
module Jikka.Core.Language.Lint
ensureWellTyped :: MonadError Error m => Program -> m ()

module Jikka.Core.Convert.ConstantPropagation

-- | <a>run</a> does constant propagation. This assumes that the program is
--   alpha-converted.
--   
--   For example, this converts the following:
--   
--   <pre>
--   let x = 1
--   in let f = fun y -&gt; y
--   in x + x + f(x)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let f = fun y -&gt; y
--   in 1 + 1 + f(1)
--   </pre>
--   
--   NOTE: this doesn't constant folding.
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program

-- | <a>isSmallExpr</a> checks whether given exprs are suitable to
--   propagate.
isSmallExpr :: Expr -> Bool

module Jikka.Core.Language.Util
genType :: MonadAlpha m => m Type
genVarName :: MonadAlpha m => VarName -> m VarName
genVarName' :: MonadAlpha m => m VarName
mapTypeInBuiltin :: (Type -> Type) -> Builtin -> Builtin
countOccurrences :: VarName -> Expr -> Int
countOccurrencesToplevelExpr :: VarName -> ToplevelExpr -> Int
mapExprM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> Expr -> m Expr
mapExprToplevelExprM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> ToplevelExpr -> m ToplevelExpr
mapExprProgramM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> Program -> m Program
mapExpr :: ([(VarName, Type)] -> Expr -> Expr) -> [(VarName, Type)] -> Expr -> Expr
mapExprToplevelExpr :: ([(VarName, Type)] -> Expr -> Expr) -> [(VarName, Type)] -> ToplevelExpr -> ToplevelExpr
mapExprProgram :: ([(VarName, Type)] -> Expr -> Expr) -> Program -> Program

module Jikka.Core.Convert.TrivialLetElimination

-- | <a>run</a> remove let-exprs whose assigned variables are used only at
--   most once. This assumes that the program is alpha-converted.
--   
--   For example, this converts the following:
--   
--   <pre>
--   let f = fun y -&gt; y
--   in let x = 1
--   in f(x + x)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let x = 1
--   in (fun y -&gt; y) (x + x)
--   </pre>
--   
--   NOTE: this doesn't constant folding.
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program

module Jikka.Core.Convert.PropagateMod

-- | <a>run</a> propagates <a>FloorMod</a> to leaves of exprs. For example,
--   this converts the following:
--   
--   <pre>
--   mod ((fun x -&gt; x * x + x) y) 1000000007
--   </pre>
--   
--   to:
--   
--   <pre>
--   (fun x -&gt; mod (mod (x * x) 1000000007 + x) 1000000007) y
--   </pre>
run :: MonadError Error m => Program -> m Program


module Jikka.Core.Convert.MakeEager

-- | <a>run</a> wraps some exprs with lambda redundant things from AST.
--   Specifically, this converts <tt>if p then a else b</tt> to something
--   like <tt>(if p then (lambda. a) else (lambda. b))()</tt>.
--   
--   For example, this converts:
--   
--   <pre>
--   let rec fact n =
--       if n == 0 then
--           1
--       else
--           n * fact (n - 1)
--   in fact 10
--   </pre>
--   
--   to:
--   
--   <pre>
--   let rec fact n =
--       (if n == 0 then
--           fun -&gt; 1
--       else
--           fun -&gt; n * fact (n - 1)
--       )()
--   in fact 10
--   </pre>
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program

module Jikka.Core.Convert.ImmediateAppToLet

-- | <a>run</a> does beta-reductions in given programs. For example, this
--   converts the following:
--   
--   <pre>
--   (fun x -&gt; x + x) a
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   let x = a in x + x
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Core.Convert.ConstantFolding

-- | <a>run</a> folds constants in given programs. For example, this
--   converts the following:
--   
--   <pre>
--   3 x + 2 + 1
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   3 x + 3
--   </pre>
run :: MonadError Error m => Program -> m Program


module Jikka.Core.Convert.ANormal

-- | <a>run</a> makes a given program A-normal form. A program is an
--   A-normal form iff assigned exprs of all let-statements are values or
--   function applications. For example, this converts the following:
--   
--   <pre>
--   (let x = 1 in x) + ((fun y -&gt; y) 1)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let x = 1
--   in let f = fun y -&gt; y
--   in let z = f x
--   in z
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Core.Language.Value
data Value
ValInt :: Integer -> Value
ValBool :: Bool -> Value
ValList :: Vector Value -> Value
ValTuple :: [Value] -> Value
ValBuiltin :: Builtin -> Value
ValLambda :: Maybe VarName -> Env -> [(VarName, Type)] -> Expr -> Value
type Env = [(VarName, Value)]
literalToValue :: Literal -> Value
valueToInt :: MonadError Error m => Value -> m Integer
valueToIntList :: MonadError Error m => Vector Value -> m [Integer]
valueToIntList' :: MonadError Error m => Value -> m [Integer]
valueToBool :: MonadError Error m => Value -> m Bool
valueToBoolList :: MonadError Error m => Vector Value -> m [Bool]
valueToVector :: MonadError Error m => Value -> m (Vector Integer)
valueToMatrix :: MonadError Error m => Value -> m (Matrix Integer)
valueFromVector :: Vector Integer -> Value
valueFromMatrix :: Matrix Integer -> Value
valueToModVector :: MonadError Error m => Integer -> Value -> m (Vector ModInt)
valueToModMatrix :: MonadError Error m => Integer -> Value -> m (Matrix ModInt)
valueFromModVector :: Vector ModInt -> Value
valueFromModMatrix :: Matrix ModInt -> Value
compareValues :: Value -> Value -> Maybe Ordering
compareValues' :: Value -> Value -> Ordering
formatValue :: Value -> String
writeValueIO :: Value -> IO ()
instance GHC.Read.Read Jikka.Core.Language.Value.Value
instance GHC.Show.Show Jikka.Core.Language.Value.Value
instance GHC.Classes.Eq Jikka.Core.Language.Value.Value


-- | <a>Evaluate</a> evaluates exprs to values. Also this recognizes users'
--   inputs at once.
--   
--   The implementation assumes that all variable names don't conflict even
--   when their scopes are distinct.
module Jikka.Core.Evaluate
run :: (MonadIO m, MonadFix m, MonadError Error m) => Program -> m Value
run' :: (MonadFix m, MonadError Error m) => [Token] -> Program -> m Value
data Value
ValInt :: Integer -> Value
ValBool :: Bool -> Value
ValList :: Vector Value -> Value
ValTuple :: [Value] -> Value
ValBuiltin :: Builtin -> Value
ValLambda :: Maybe VarName -> Env -> [(VarName, Type)] -> Expr -> Value
newtype Token
Token :: String -> Token
[unToken] :: Token -> String
tokenize :: String -> [Token]
instance GHC.Read.Read Jikka.Core.Evaluate.Token
instance GHC.Show.Show Jikka.Core.Evaluate.Token
instance GHC.Classes.Ord Jikka.Core.Evaluate.Token
instance GHC.Classes.Eq Jikka.Core.Evaluate.Token


module Jikka.Core.Language.Vars

-- | <a>isFreeVar</a> checks if the given variable occurs in the tiven
--   expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam1 (VarName "y") IntTy (Var (VarName "x"))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam1 (VarName "x") IntTy (Var (VarName "x"))
--   False
--   </pre>
isFreeVar :: VarName -> Expr -> Bool

-- | <a>isUnusedVar</a> is the negation of <a>isFreeVar</a>.
--   
--   TODO: rename to <tt>isNonFreeVar</tt>?
isUnusedVar :: VarName -> Expr -> Bool

-- | <a>isFreeVarOrScopedVar</a> checks if the given variable occurs in the
--   tiven expr. This ignores contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVarOrScopedVar` Lam1 (VarName "x") IntTy (Var (VarName "y"))
--   True
--   </pre>
isFreeVarOrScopedVar :: VarName -> Expr -> Bool

-- | <a>findFreshVar</a> generates a variable which isn't free in the given
--   expr. The return variable name may conflict if you ignores the
--   context.
findFreshVar :: Expr -> VarName

-- | TODO: make a function to list free/scoped vars and use it to optimize
--   the time complexity.
findFreshVar' :: [Expr] -> VarName
getAnonymousVar :: Int -> VarName
freeTyVars :: Type -> [TypeName]


module Jikka.Core.Language.Beta

-- | <a>substitute</a> replaces the occrences of the given variable with
--   the given expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; substitute (VarName "x") (Lit (LitInt 0)) (Lam1 (VarName "y") IntTy (Var (VarName "x")))
--   Lam [(VarName "y",IntTy)] (Lit (LitInt 0))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; substitute (VarName "x") (Lit (LitInt 0)) (Lam1 (VarName "x") IntTy (Var (VarName "x")))
--   Lam [(VarName "x",IntTy)] (Var (VarName "x"))
--   </pre>
substitute :: VarName -> Expr -> Expr -> Expr
substitute' :: [VarName] -> VarName -> Expr -> Expr -> Expr


-- | <a>FromCore</a> converts exprs of our core language to exprs of C++.
module Jikka.CPlusPlus.Convert.FromCore
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
instance GHC.Read.Read Jikka.CPlusPlus.Convert.FromCore.NameKind
instance GHC.Show.Show Jikka.CPlusPlus.Convert.FromCore.NameKind
instance GHC.Classes.Ord Jikka.CPlusPlus.Convert.FromCore.NameKind
instance GHC.Classes.Eq Jikka.CPlusPlus.Convert.FromCore.NameKind

module Jikka.CPlusPlus.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Core.Language.ArithmeticalExpr
data ProductExpr
ProductExpr :: Integer -> [Expr] -> ProductExpr
[productExprConst] :: ProductExpr -> Integer
[productExprList] :: ProductExpr -> [Expr]
data SumExpr
SumExpr :: [ProductExpr] -> Integer -> SumExpr
[sumExprList] :: SumExpr -> [ProductExpr]
[sumExprConst] :: SumExpr -> Integer
type ArithmeticalExpr = SumExpr
oneProductExpr :: ProductExpr
negateProductExpr :: ProductExpr -> ProductExpr
multProductExpr :: ProductExpr -> ProductExpr -> ProductExpr
parseProductExpr :: Expr -> ProductExpr
sumExprFromProductExpr :: ProductExpr -> SumExpr
sumExprFromInteger :: Integer -> SumExpr
zeroSumExpr :: SumExpr
negateSumExpr :: SumExpr -> SumExpr
plusSumExpr :: SumExpr -> SumExpr -> SumExpr
multSumExpr :: SumExpr -> SumExpr -> SumExpr
parseSumExpr :: Expr -> SumExpr

-- | <a>parseArithmeticalExpr</a> converts a given expr to a normal form
--   &lt;math&gt;. This assumes given exprs have the type &lt;math&gt;.
parseArithmeticalExpr :: Expr -> ArithmeticalExpr
formatProductExpr :: ProductExpr -> Expr
formatSumExpr :: SumExpr -> Expr
formatArithmeticalExpr :: ArithmeticalExpr -> Expr
normalizeProductExpr :: ProductExpr -> ProductExpr
normalizeSumExpr :: SumExpr -> SumExpr
normalizeArithmeticalExpr :: ArithmeticalExpr -> ArithmeticalExpr

-- | <a>makeVectorFromArithmeticalExpr</a> makes a vector &lt;math&gt; and
--   a expr &lt;math&gt; from a given vector of variables &lt;math&gt; and
--   a given expr &lt;math&gt; s.t. &lt;math&gt; and &lt;math&gt; don't
--   have &lt;math&gt; as free variables and &lt;math&gt; holds. This
--   assumes given variables and exprs have the type &lt;math&gt;.
makeVectorFromArithmeticalExpr :: Vector VarName -> ArithmeticalExpr -> Maybe (Vector ArithmeticalExpr, ArithmeticalExpr)
instance GHC.Read.Read Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Show.Show Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Classes.Ord Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Classes.Eq Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Read.Read Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Show.Show Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Classes.Ord Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Classes.Eq Jikka.Core.Language.ArithmeticalExpr.SumExpr

module Jikka.Core.Convert.TypeInfer

-- | <a>run</a> does type inference. This assumes that program has no name
--   conflicts.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
data Equation
TypeEquation :: Type -> Type -> Equation
TypeAssertion :: VarName -> Type -> Equation
formularizeProgram :: MonadAlpha m => Program -> m [Equation]
sortEquations :: [Equation] -> ([(Type, Type)], [(VarName, Type)])
mergeAssertions :: [(VarName, Type)] -> [(Type, Type)]

-- | <a>Subst</a> is type substituion. It's a mapping from type variables
--   to their actual types.
newtype Subst
Subst :: Map TypeName Type -> Subst
[unSubst] :: Subst -> Map TypeName Type
subst :: Subst -> Type -> Type
solveEquations :: MonadError Error m => [(Type, Type)] -> m Subst
substProgram :: Subst -> Program -> Program
instance GHC.Read.Read Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Show.Show Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Classes.Ord Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Classes.Eq Jikka.Core.Convert.TypeInfer.Equation


-- | <a>StrengthReduction</a> replaces strong functions in exprs with
--   weaker functions. For example, this replace <tt>abs x</tt> with
--   <tt>max x (- x)</tt>.
module Jikka.Core.Convert.StrengthReduction
run :: MonadError Error m => Program -> m Program


-- | <a>RemoveUnusedVars</a> remove unused variables from exprs.
module Jikka.Core.Convert.RemoveUnusedVars

-- | <a>run</a> removes unused variables in given programs.
--   
--   This also removes variables for recursion, i.e. "rec" flags.
--   <a>ToplevelLetRec</a> may becomes <a>ToplevelLet</a>.
--   
--   For example, this converts
--   
--   <pre>
--   let rec solve x =
--       let y = 0
--       in x
--   in solve
--   </pre>
--   
--   to
--   
--   <pre>
--   let solve x =
--       x
--   in solve
--   </pre>
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program

module Jikka.Core.Convert.LinearFunction

-- | <a>run</a> simplifies a functions from tuples of integers to tuples of
--   integers. For example, this converts the following:
--   
--   <pre>
--   fun xs -&gt; (xs[0] + 2 * xs[1], xs[1])
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   (fun xs -&gt; matap ((1, 2), (0, 1)) xs)
--   </pre>
--   
--   TODO: support affine functions
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


-- | <a>Convert</a> is a module to combine other all optimizers.
module Jikka.Core.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Main.Target
data Target
PythonTarget :: Target
RestrictedPythonTarget :: Target
CoreTarget :: Target
CPlusPlusTarget :: Target
parseTarget :: String -> Either Error Target
instance GHC.Read.Read Jikka.Main.Target.Target
instance GHC.Show.Show Jikka.Main.Target.Target
instance GHC.Classes.Ord Jikka.Main.Target.Target
instance GHC.Classes.Eq Jikka.Main.Target.Target


-- | <a>Expr</a> module has the basic data types for the standard Python.
--   See the Python's <tt>ast</tt> module
--   (<a>https://docs.python.org/ja/3/library/ast.html#abstract-grammar</a>)
--   for reference.
module Jikka.Python.Language.Expr
newtype Ident
Ident :: String -> Ident
unIdent :: Ident -> String
type Ident' = WithLoc Ident
data Constant
ConstNone :: Constant
ConstInt :: Integer -> Constant
ConstBool :: Bool -> Constant
ConstString :: String -> Constant
ConstBytes :: [Int8] -> Constant
ConstFloat :: Double -> Constant
ConstImaginary :: Double -> Constant
data Statement
FunctionDef :: Ident' -> Arguments -> [Statement'] -> [Decorator] -> Maybe Type' -> Statement
AsyncFunctionDef :: Ident' -> Arguments -> [Statement'] -> [Decorator] -> Maybe Type' -> Statement
ClassDef :: Ident' -> [Expr'] -> [Keyword'] -> [Statement'] -> [Decorator] -> Statement
Return :: Maybe Expr' -> Statement
Delete :: [Target'] -> Statement
Assign :: [Target'] -> Expr' -> Statement
AugAssign :: Target' -> Operator -> Expr' -> Statement
AnnAssign :: Target' -> Type' -> Maybe Expr' -> Statement

-- | <pre>
--   For target iter body orelse
--   </pre>
For :: Target' -> Expr' -> [Statement'] -> [Statement'] -> Statement
AsyncFor :: Target' -> Expr' -> [Statement'] -> [Statement'] -> Statement

-- | <pre>
--   While test body orelse
--   </pre>
While :: Expr' -> [Statement'] -> [Statement'] -> Statement
If :: Expr' -> [Statement'] -> [Statement'] -> Statement
With :: [WithItem] -> [Statement'] -> Statement
AsyncWith :: [WithItem] -> [Statement'] -> Statement

-- | <tt>Raise exc cause</tt> represents <tt>raise exc from cause</tt>.
Raise :: Maybe Expr' -> Maybe Expr' -> Statement

-- | <pre>
--   Try body handlers orelse finalbody
--   </pre>
Try :: [Statement'] -> [ExceptHandler'] -> [Statement'] -> [Statement'] -> Statement

-- | <pre>
--   Assert test msg
--   </pre>
Assert :: Expr' -> Maybe Expr' -> Statement
Import :: [Alias] -> Statement
ImportFrom :: [Ident'] -> [Alias] -> Statement
Global :: [Ident'] -> Statement
Nonlocal :: [Ident'] -> Statement
Expr' :: Expr' -> Statement
Pass :: Statement
Break :: Statement
Continue :: Statement
type Statement' = WithLoc Statement
data Expr
BoolOp :: Expr' -> BoolOp -> Expr' -> Expr

-- | produced by the walrus operator <tt>:=</tt>
NamedExpr :: Target' -> Expr' -> Expr
BinOp :: Expr' -> Operator -> Expr' -> Expr
UnaryOp :: UnaryOp -> Expr' -> Expr
Lambda :: Arguments -> Expr' -> Expr

-- | <pre>
--   IfExp test body orelse
--   </pre>
IfExp :: Expr' -> Expr' -> Expr' -> Expr

-- | NULL key is for <tt>**d</tt>.
Dict :: [(Maybe Expr', Expr')] -> Expr
Set :: [Expr'] -> Expr
ListComp :: Expr' -> [Comprehension] -> Expr
SetComp :: Expr' -> [Comprehension] -> Expr
DictComp :: Expr' -> Expr' -> [Comprehension] -> Expr
GeneratorExp :: Expr' -> [Comprehension] -> Expr
Await :: Expr' -> Expr
Yield :: Maybe Expr' -> Expr
YieldFrom :: Expr' -> Expr
Compare :: Expr' -> [(CmpOp, Expr')] -> Expr
Call :: Expr' -> [Expr'] -> [Keyword'] -> Expr

-- | <tt>FormattedValue value conversion format_spec</tt> for f-strings
FormattedValue :: Expr' -> Maybe Char -> Maybe Expr' -> Expr
JoinedStr :: [Expr'] -> Expr
Constant :: Constant -> Expr

-- | can appear in assignment context
Attribute :: Expr' -> Ident' -> Expr

-- | can appear in assignment context
Subscript :: Expr' -> Expr' -> Expr

-- | can appear in assignment context
Starred :: Expr' -> Expr

-- | can appear in assignment context
Name :: Ident' -> Expr

-- | can appear in assignment context
List :: [Expr'] -> Expr

-- | can appear in assignment context
Tuple :: [Expr'] -> Expr

-- | <tt>Slice lower upper step</tt> can appear only in Subscript
Slice :: Maybe Expr' -> Maybe Expr' -> Maybe Expr' -> Expr
type Expr' = WithLoc Expr
type Target = Expr'
type Target' = Expr'
type Type = Expr'
type Type' = Expr'
type Decorator = Expr'
type Decorator' = Expr'
data ExprContext
Load :: ExprContext
Store :: ExprContext
Del :: ExprContext
data BoolOp
And :: BoolOp
Or :: BoolOp

-- | our extension
Implies :: BoolOp
data Operator
Add :: Operator
Sub :: Operator
Mult :: Operator
MatMult :: Operator
Div :: Operator
FloorDiv :: Operator
FloorMod :: Operator

-- | our extension
CeilDiv :: Operator

-- | our extension
CeilMod :: Operator
Pow :: Operator
BitLShift :: Operator
BitRShift :: Operator
BitOr :: Operator
BitXor :: Operator
BitAnd :: Operator

-- | our extension
Max :: Operator

-- | our extension
Min :: Operator
data UnaryOp

-- | on int
Invert :: UnaryOp

-- | on bool
Not :: UnaryOp
UAdd :: UnaryOp
USub :: UnaryOp
data CmpOp
Eq' :: CmpOp
NotEq :: CmpOp
Lt :: CmpOp
LtE :: CmpOp
Gt :: CmpOp
GtE :: CmpOp
Is :: CmpOp
IsNot :: CmpOp
In :: CmpOp
NotIn :: CmpOp

-- | <pre>
--   Comprehension target iter ifs is_async
--   </pre>
data Comprehension
Comprehension :: Target' -> Expr' -> Maybe Expr' -> Comprehension
[compTarget] :: Comprehension -> Target'
[compIter] :: Comprehension -> Expr'
[compIfs] :: Comprehension -> Maybe Expr'
data ExceptHandler
ExceptHandler :: Maybe Type' -> Maybe Ident' -> [Statement'] -> ExceptHandler
[exchType] :: ExceptHandler -> Maybe Type'
[exchName] :: ExceptHandler -> Maybe Ident'
[exchBody] :: ExceptHandler -> [Statement']
type ExceptHandler' = WithLoc ExceptHandler
data Arguments
Arguments :: [Arg] -> [Arg] -> Maybe Arg -> [Arg] -> [Expr'] -> Maybe Arg -> [Expr'] -> Arguments
[argsPosonlyargs] :: Arguments -> [Arg]
[argsArgs] :: Arguments -> [Arg]
[argsVarargs] :: Arguments -> Maybe Arg
[argsKwonlyargs] :: Arguments -> [Arg]
[argsKwDefaults] :: Arguments -> [Expr']
[argsKwarg] :: Arguments -> Maybe Arg
[argsDefaults] :: Arguments -> [Expr']
emptyArguments :: Arguments
type Arg = (Ident', Maybe Type')

-- | NULL identifier is for <tt>**kwargs</tt>.
type Keyword = (Maybe Ident', Expr')
type Keyword' = WithLoc Keyword

-- | <tt>(name, asname)</tt>. <a>Alias</a> is used for <a>Import</a> and
--   <a>ImportFrom</a>.
type Alias = (Ident', Maybe Ident')

-- | <pre>
--   (context_expr, optional_vars)
--   </pre>
type WithItem = (Expr', Maybe Expr')
type Program = [Statement']
instance Data.String.IsString Jikka.Python.Language.Expr.Ident
instance GHC.Read.Read Jikka.Python.Language.Expr.Ident
instance GHC.Show.Show Jikka.Python.Language.Expr.Ident
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Ident
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Ident
instance GHC.Read.Read Jikka.Python.Language.Expr.Constant
instance GHC.Show.Show Jikka.Python.Language.Expr.Constant
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Constant
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Constant
instance GHC.Read.Read Jikka.Python.Language.Expr.ExprContext
instance GHC.Show.Show Jikka.Python.Language.Expr.ExprContext
instance GHC.Classes.Ord Jikka.Python.Language.Expr.ExprContext
instance GHC.Classes.Eq Jikka.Python.Language.Expr.ExprContext
instance GHC.Read.Read Jikka.Python.Language.Expr.BoolOp
instance GHC.Show.Show Jikka.Python.Language.Expr.BoolOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.BoolOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.BoolOp
instance GHC.Read.Read Jikka.Python.Language.Expr.Operator
instance GHC.Show.Show Jikka.Python.Language.Expr.Operator
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Operator
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Operator
instance GHC.Read.Read Jikka.Python.Language.Expr.UnaryOp
instance GHC.Show.Show Jikka.Python.Language.Expr.UnaryOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.UnaryOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.UnaryOp
instance GHC.Read.Read Jikka.Python.Language.Expr.CmpOp
instance GHC.Show.Show Jikka.Python.Language.Expr.CmpOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.CmpOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.CmpOp
instance GHC.Read.Read Jikka.Python.Language.Expr.Comprehension
instance GHC.Show.Show Jikka.Python.Language.Expr.Comprehension
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Comprehension
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Comprehension
instance GHC.Read.Read Jikka.Python.Language.Expr.Arguments
instance GHC.Show.Show Jikka.Python.Language.Expr.Arguments
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Arguments
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Arguments
instance GHC.Read.Read Jikka.Python.Language.Expr.Expr
instance GHC.Show.Show Jikka.Python.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Expr
instance GHC.Read.Read Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Show.Show Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Classes.Ord Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Classes.Eq Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Read.Read Jikka.Python.Language.Expr.Statement
instance GHC.Show.Show Jikka.Python.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Statement

module Jikka.Python.Language.Util
constIntExp :: Integer -> Expr
constBoolExp :: Bool -> Expr
mapExprArgumentsM :: Monad m => (Expr' -> m Expr') -> Arguments -> m Arguments
mapExprComprehensionM :: Monad m => (Expr' -> m Expr') -> Comprehension -> m Comprehension
mapExprComprehensionsM :: Monad m => (Expr' -> m Expr') -> [Comprehension] -> m [Comprehension]
mapExprKeywordsM :: Monad m => (Expr' -> m Expr') -> [Keyword'] -> m [Keyword']
mapExprM :: Monad m => (Expr' -> m Expr') -> Expr' -> m Expr'
mapExprExceptHanderM :: Monad m => (Expr' -> m Expr') -> ExceptHandler' -> m ExceptHandler'
mapExprStatementM :: Monad m => (Expr' -> m Expr') -> Statement' -> m Statement'
mapExprStatementsM :: Monad m => (Expr' -> m Expr') -> [Statement'] -> m [Statement']
mapExprProgramM :: Monad m => (Expr' -> m Expr') -> Program -> m Program
mapExprProgram :: (Expr' -> Expr') -> Program -> Program


module Jikka.Python.Parse.Token
data CmpOp
DoubleEqual :: CmpOp
NotEqual :: CmpOp
LessThan :: CmpOp
LessEqual :: CmpOp
GreaterThan :: CmpOp
GreaterEqual :: CmpOp
data DivModOp
Div :: DivModOp
FloorDiv :: DivModOp
FloorMod :: DivModOp
CeilDiv :: DivModOp
CeilMod :: DivModOp
data AugOp
AugAdd :: AugOp
AugSub :: AugOp
AugMul :: AugOp
AugAt :: AugOp
AugDiv :: AugOp
AugFloorDiv :: AugOp
AugFloorMod :: AugOp
AugCeilDiv :: AugOp
AugCeilMod :: AugOp
AugPow :: AugOp
AugBitRShift :: AugOp
AugBitLShift :: AugOp
AugBitAnd :: AugOp
AugBitXor :: AugOp
AugBitOr :: AugOp
AugMin :: AugOp
AugMax :: AugOp

-- | We don't have to classify tokens in detail, but it's convenient for
--   testing and debugging.
data Token
None :: Token
Int :: Integer -> Token
Bool :: Bool -> Token
String :: String -> Token
Bytes :: [Int8] -> Token
Float :: Double -> Token
Imaginary :: Double -> Token
Def :: Token
If :: Token
Elif :: Token
Else :: Token
For :: Token
In :: Token
Assert :: Token
Return :: Token
Lambda :: Token
Arrow :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Dot :: Token
Equal :: Token
Underscore :: Token
OpenBrace :: Token
OpenBracket :: Token
OpenParen :: Token
CloseBrace :: Token
CloseBracket :: Token
CloseParen :: Token
Ident :: String -> Token
WalrusOp :: Token
ImpliesOp :: Token
OrOp :: Token
AndOp :: Token
NotOp :: Token
CmpOp :: CmpOp -> Token
MinOp :: Token
MaxOp :: Token
BitOrOp :: Token
BitXorOp :: Token
BitAndOp :: Token
BitLShiftOp :: Token
BitRShiftOp :: Token
PlusOp :: Token
MinusOp :: Token
MulOp :: Token
DivModOp :: DivModOp -> Token
AtOp :: Token
BitNotOp :: Token
PowOp :: Token
AugOp :: AugOp -> Token
Newline :: Token
Indent :: Token
Dedent :: Token
As :: Token
Async :: Token
Await :: Token
Break :: Token
Class :: Token
Continue :: Token
Del :: Token
Except :: Token
Finally :: Token
From :: Token
Global :: Token
Import :: Token
Is :: Token
Nonlocal :: Token
Pass :: Token
Raise :: Token
Try :: Token
While :: Token
With :: Token
Yield :: Token
type Token' = WithLoc Token
instance GHC.Read.Read Jikka.Python.Parse.Token.CmpOp
instance GHC.Show.Show Jikka.Python.Parse.Token.CmpOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.CmpOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.CmpOp
instance GHC.Read.Read Jikka.Python.Parse.Token.DivModOp
instance GHC.Show.Show Jikka.Python.Parse.Token.DivModOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.DivModOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.DivModOp
instance GHC.Read.Read Jikka.Python.Parse.Token.AugOp
instance GHC.Show.Show Jikka.Python.Parse.Token.AugOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.AugOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.AugOp
instance GHC.Read.Read Jikka.Python.Parse.Token.Token
instance GHC.Show.Show Jikka.Python.Parse.Token.Token
instance GHC.Classes.Ord Jikka.Python.Parse.Token.Token
instance GHC.Classes.Eq Jikka.Python.Parse.Token.Token


module Jikka.Python.Parse.Happy
run :: MonadError Error m => [WithLoc Token] -> m Program


-- | <ul>
--   <li>TODO: tokenize float literals</li>
--   <li>TODO: tokenize string literals</li>
--   </ul>
module Jikka.Python.Parse.Alex
run :: MonadError Error m => String -> m [Token']
instance GHC.Show.Show Jikka.Python.Parse.Alex.AlexPosn
instance GHC.Classes.Eq Jikka.Python.Parse.Alex.AlexPosn
instance GHC.Base.Functor Jikka.Python.Parse.Alex.Alex
instance GHC.Base.Applicative Jikka.Python.Parse.Alex.Alex
instance GHC.Base.Monad Jikka.Python.Parse.Alex.Alex

module Jikka.Python.Parse
run :: MonadError Error m => FilePath -> Text -> m Program


module Jikka.RestrictedPython.Language.Expr
newtype TypeName
TypeName :: String -> TypeName
unTypeName :: TypeName -> String

-- | <a>Type</a> represents the types of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
--   
--   NOTE: &lt;math&gt; is represented as the 0-tuple.
data Type
VarTy :: TypeName -> Type
IntTy :: Type
BoolTy :: Type
ListTy :: Type -> Type
TupleTy :: [Type] -> Type
CallableTy :: [Type] -> Type -> Type
data UnaryOp

-- | on int
Invert :: UnaryOp

-- | on bool
Not :: UnaryOp
UAdd :: UnaryOp
USub :: UnaryOp
data Operator
Add :: Operator
Sub :: Operator
Mult :: Operator
MatMult :: Operator
Div :: Operator
FloorDiv :: Operator
FloorMod :: Operator

-- | our extension
CeilDiv :: Operator

-- | our extension
CeilMod :: Operator
Pow :: Operator
BitLShift :: Operator
BitRShift :: Operator
BitOr :: Operator
BitXor :: Operator
BitAnd :: Operator

-- | our extension
Max :: Operator

-- | our extension
Min :: Operator
data BoolOp
And :: BoolOp
Or :: BoolOp

-- | our extension
Implies :: BoolOp
data CmpOp
Eq' :: CmpOp
NotEq :: CmpOp
Lt :: CmpOp
LtE :: CmpOp
Gt :: CmpOp
GtE :: CmpOp
Is :: CmpOp
IsNot :: CmpOp
In :: CmpOp
NotIn :: CmpOp

-- | <a>CmpOp</a>` is a type for comparision operators. This is annotated
--   with its type as let-polymorphism.
data CmpOp'
CmpOp' :: CmpOp -> Type -> CmpOp'
data Constant
ConstNone :: Constant
ConstInt :: Integer -> Constant
ConstBool :: Bool -> Constant
ConstBuiltin :: Builtin -> Constant
data Builtin

-- | "abs" &lt;math&gt;
BuiltinAbs :: Builtin

-- | "pow" &lt;math&gt;
BuiltinPow :: Builtin

-- | modulo power "pow" &lt;math&gt;
BuiltinModPow :: Builtin

-- | "divmod" &lt;math&gt;
BuiltinDivMod :: Builtin

-- | ceil div &lt;math&gt;
BuiltinCeilDiv :: Builtin

-- | ceil mod &lt;math&gt;
BuiltinCeilMod :: Builtin

-- | floor div &lt;math&gt;
BuiltinFloorDiv :: Builtin

-- | floor mod &lt;math&gt;
BuiltinFloorMod :: Builtin

-- | &lt;math&gt;
BuiltinGcd :: Builtin

-- | &lt;math&gt;
BuiltinLcm :: Builtin

-- | "int" &lt;math&gt;
BuiltinInt :: Type -> Builtin

-- | "bool" &lt;math&gt;
BuiltinBool :: Type -> Builtin

-- | "list" &lt;math&gt;
BuiltinList :: Type -> Builtin

-- | "tuple" &lt;math&gt; where &lt;math&gt;
BuiltinTuple :: [Type] -> Builtin

-- | "len" &lt;math&gt;
BuiltinLen :: Type -> Builtin

-- | "map" &lt;math&gt;
BuiltinMap :: [Type] -> Type -> Builtin

-- | "sorted" &lt;math&gt;
BuiltinSorted :: Type -> Builtin

-- | "reversed" &lt;math&gt;
BuiltinReversed :: Type -> Builtin

-- | "enumerate" &lt;math&gt;
BuiltinEnumerate :: Type -> Builtin

-- | "filter" &lt;math&gt;
BuiltinFilter :: Type -> Builtin

-- | "zip" &lt;math&gt;
BuiltinZip :: [Type] -> Builtin

-- | "all" &lt;math&gt;
BuiltinAll :: Builtin

-- | "any" &lt;math&gt;
BuiltinAny :: Builtin

-- | "sum" &lt;math&gt;
BuiltinSum :: Builtin

-- | product &lt;math&gt;
BuiltinProduct :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange1 :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange2 :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange3 :: Builtin

-- | "max" &lt;math&gt;
BuiltinMax1 :: Type -> Builtin

-- | "max" &lt;math&gt;
BuiltinMax :: Type -> Int -> Builtin

-- | "min" &lt;math&gt;
BuiltinMin1 :: Type -> Builtin

-- | "min" &lt;math&gt;
BuiltinMin :: Type -> Int -> Builtin

-- | &lt;math&gt;
BuiltinArgMax :: Type -> Builtin

-- | &lt;math&gt;
BuiltinArgMin :: Type -> Builtin

-- | factorial &lt;math&gt;
BuiltinFact :: Builtin

-- | &lt;math&gt;
BuiltinChoose :: Builtin

-- | &lt;math&gt;
BuiltinPermute :: Builtin

-- | &lt;math&gt;
BuiltinMultiChoose :: Builtin

-- | modulo inverse &lt;math&gt;
BuiltinModInv :: Builtin
newtype VarName
VarName :: String -> VarName
unVarName :: VarName -> String
type VarName' = WithLoc' VarName

-- | <a>Expr</a> represents the exprs of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
data Expr
BoolOp :: Expr' -> BoolOp -> Expr' -> Expr
BinOp :: Expr' -> Operator -> Expr' -> Expr
UnaryOp :: UnaryOp -> Expr' -> Expr
Lambda :: [(VarName', Type)] -> Expr' -> Expr
IfExp :: Expr' -> Expr' -> Expr' -> Expr
ListComp :: Expr' -> Comprehension -> Expr
Compare :: Expr' -> CmpOp' -> Expr' -> Expr
Call :: Expr' -> [Expr'] -> Expr
Constant :: Constant -> Expr
Subscript :: Expr' -> Expr' -> Expr
Name :: VarName' -> Expr
List :: Type -> [Expr'] -> Expr
Tuple :: [Expr'] -> Expr
SubscriptSlice :: Expr' -> Maybe Expr' -> Maybe Expr' -> Maybe Expr' -> Expr
type Expr' = WithLoc' Expr
data Comprehension
Comprehension :: Target' -> Expr' -> Maybe Expr' -> Comprehension

-- | <a>Target</a> represents the lvalue of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
data Target
SubscriptTrg :: Target' -> Expr' -> Target
NameTrg :: VarName' -> Target
TupleTrg :: [Target'] -> Target
type Target' = WithLoc' Target

-- | <a>Statement</a> represents the statements of our restricted
--   Python-like language. They appear in bodies of <tt>def</tt>.
--   
--   &lt;math&gt;
data Statement
Return :: Expr' -> Statement
AugAssign :: Target' -> Operator -> Expr' -> Statement
AnnAssign :: Target' -> Type -> Expr' -> Statement
For :: Target' -> Expr' -> [Statement] -> Statement
If :: Expr' -> [Statement] -> [Statement] -> Statement
Assert :: Expr' -> Statement

-- | <tt>TopLevelStatement</tt> represents the statements of our restricted
--   Python-like language. They appear in the toplevel of programs.
--   
--   &lt;math&gt;
data ToplevelStatement
ToplevelAnnAssign :: VarName' -> Type -> Expr' -> ToplevelStatement
ToplevelFunctionDef :: VarName' -> [(VarName', Type)] -> Type -> [Statement] -> ToplevelStatement
ToplevelAssert :: Expr' -> ToplevelStatement

-- | <a>Program</a> represents the programs of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
type Program = [ToplevelStatement]
instance Data.String.IsString Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.VarName
instance Data.String.IsString Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.ToplevelStatement

module Jikka.RestrictedPython.Language.Util
genType :: MonadAlpha m => m Type
genVarName :: MonadAlpha m => VarName' -> m VarName'
freeTyVars :: Type -> [TypeName]

-- | <a>freeVars</a>` reports all free variables.
freeVars :: Expr' -> [VarName]

-- | <a>freeVars</a>` reports all free variables with their locations, i.e.
--   occurrences. For examples, <tt>x + x</tt> and <tt>x</tt> have the same
--   free variables <tt>x</tt> but they have different sets of occurrences
--   of free variable.
freeVars' :: Expr' -> [VarName']
freeVarsTarget :: Target' -> [VarName]
freeVarsTarget' :: Target' -> [VarName']
doesAlwaysReturn :: Statement -> Bool
doesPossiblyReturn :: Statement -> Bool
mapStatement :: (Statement -> [Statement]) -> Program -> Program

-- | <a>mapStatementM</a> replaces all statements in a given program using
--   a given function. This may breaks various constraints.
mapStatementM :: Monad m => (Statement -> m [Statement]) -> Program -> m Program
mapLargeStatement :: (Expr' -> [Statement] -> [Statement] -> [Statement]) -> (Target' -> Expr' -> [Statement] -> [Statement]) -> Program -> Program
mapLargeStatementM :: Monad m => (Expr' -> [Statement] -> [Statement] -> m [Statement]) -> (Target' -> Expr' -> [Statement] -> m [Statement]) -> Program -> m Program
mapStatements :: ([Statement] -> [Statement]) -> Program -> Program
mapStatementsM :: Monad m => ([Statement] -> m [Statement]) -> Program -> m Program
listStatements :: Program -> [Statement]

-- | <a>mapSubExprM</a> replaces all exprs in a given expr using a given
--   function. This may breaks various constraints.
mapSubExprM :: Monad m => (Expr' -> m Expr') -> Expr' -> m Expr'
listSubExprs :: Expr' -> [Expr']
mapExprTargetM :: Monad m => (Expr' -> m Expr') -> Target' -> m Target'
mapExprStatementM :: Monad m => (Expr' -> m Expr') -> Statement -> m Statement
mapExprM :: Monad m => (Expr' -> m Expr') -> Program -> m Program
listExprs :: Program -> [Expr']
hasFunctionCall :: Expr' -> Bool

-- | <a>isSmallExpr</a> is true if the evaluation of a given expr trivially
--   terminates.
isSmallExpr :: Expr' -> Bool
targetVars :: Target' -> [VarName]
targetVars' :: Target' -> [VarName']
hasSubscriptTrg :: Target' -> Bool
hasBareNameTrg :: Target' -> Bool
toplevelMainDef :: [Statement] -> Program
readValueIO :: (MonadIO m, MonadError Error m) => Type -> m Expr'

module Jikka.RestrictedPython.Language.Builtin
builtinNames :: Set VarName
standardBuiltinNames :: Set VarName
additionalBuiltinNames :: Set VarName

-- | <a>resolveUniqueBuiltin</a> makes a builtin function from a variable
--   name. However, this doesn't anything for ambiguous builtin functions.
--   For example, the builtin function "max" is kept as a variable because
--   it may be &lt;math&gt;, &lt;math&gt;, etc. and this function cannot
--   resolve it.
resolveUniqueBuiltin :: (MonadAlpha m, MonadError Error m) => VarName' -> m Expr'
resolveBuiltin :: (MonadAlpha m, MonadError Error m) => VarName' -> Int -> m Expr'
formatBuiltin :: Builtin -> String
typeBuiltin :: Builtin -> Type


module Jikka.RestrictedPython.Format
run :: Applicative m => Program -> m Text
run' :: Program -> String
formatType :: Type -> String


module Jikka.RestrictedPython.Convert.TypeInfer

-- | <a>run</a> infers types of given programs.
--   
--   There must be no name conflicts in given programs. They must be
--   alpha-converted.
--   
--   As the interface, you can understand this function does the following:
--   
--   <ol>
--   <li>Finds a type environment &lt;math&gt; s.t. for all statement
--   &lt;math&gt; in the given program, &lt;math&gt; holds, and</li>
--   <li>Annotates each variable in the program using the
--   &lt;math&gt;.</li>
--   </ol>
--   
--   In its implementation, this is just something like a Hindley-Milner
--   type inference.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
data Equation
TypeEquation :: Type -> Type -> Maybe Loc -> Equation
TypeAssertion :: VarName' -> Type -> Equation
formularizeProgram :: MonadAlpha m => Program -> m [Equation]
sortEquations :: [Equation] -> ([(Type, Type, Maybe Loc)], [(VarName', Type)])
mergeAssertions :: [(VarName', Type)] -> [(Type, Type, Maybe Loc)]

-- | <a>Subst</a> is type substituion. It's a mapping from type variables
--   to their actual types.
newtype Subst
Subst :: Map TypeName Type -> Subst
[unSubst] :: Subst -> Map TypeName Type
subst :: Subst -> Type -> Type
solveEquations :: MonadError Error m => [(Type, Type, Maybe Loc)] -> m Subst
substProgram :: Subst -> Program -> Program
instance GHC.Read.Read Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Show.Show Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Classes.Ord Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Classes.Eq Jikka.RestrictedPython.Convert.TypeInfer.Equation

module Jikka.RestrictedPython.Convert.RemoveUnreachable

-- | <a>run</a> removes unreachable statements after return-statements.
--   
--   For example, the following
--   
--   <pre>
--   a = 0
--   if True:
--       b = 0
--       return b
--       b += 1
--   else:
--       return 1
--   a += 1
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   a = 0
--   if True:
--       b = 0
--       return b
--   else:
--       return 1
--   </pre>
run :: Program -> Program

module Jikka.RestrictedPython.Convert.RemoveUnbalancedIf

-- | <a>run</a> removes if-statements that one branch always returns and
--   the other branch doesn't.
--   
--   For example, the following
--   
--   <pre>
--   if True:
--       return 0
--   else:
--       a = 0
--   b = 1
--   return 2
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   if True:
--       return 0
--   else:
--       a = 0
--       b = 1
--       return 2
--   </pre>
run :: Program -> Program

module Jikka.Python.Convert.ToRestrictedPython
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.RestrictedPython.Language.Value

-- | <a>Value</a> is the values of our restricted Python-like language.
--   
--   &lt;math&gt;
data Value
IntVal :: Integer -> Value
BoolVal :: Bool -> Value
ListVal :: Vector Value -> Value
TupleVal :: [Value] -> Value
ClosureVal :: Local -> [(VarName, Type)] -> [Statement] -> Value
BuiltinVal :: Builtin -> Value
newtype Local
Local :: Map VarName Value -> Local
[unLocal] :: Local -> Map VarName Value
toList :: MonadError Error m => Value -> m (Vector Value)
toIntList :: Vector Value -> Maybe (Vector Integer)
toIntList' :: MonadError Error m => Vector Value -> m (Vector Integer)
toBoolList' :: MonadError Error m => Vector Value -> m (Vector Bool)
toMatrix :: Vector Value -> Maybe (Matrix Integer)
toMatrix' :: MonadError Error m => Vector Value -> m (Matrix Integer)
fromMatrix :: Matrix Integer -> Value
compareValues :: Value -> Value -> Maybe Ordering
compareValues' :: Value -> Value -> Ordering
newtype Global
Global :: Map VarName Value -> Global
[unGlobal] :: Global -> Map VarName Value
initialGlobal :: Global
lookupGlobal :: MonadError Error m => VarName' -> Global -> m Value
makeEntryPointIO :: (MonadIO m, MonadError Error m) => VarName' -> Global -> m Expr'
formatValue :: Value -> String
writeValueIO :: Value -> IO ()
instance GHC.Read.Read Jikka.RestrictedPython.Language.Value.Value
instance GHC.Show.Show Jikka.RestrictedPython.Language.Value.Value
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Value.Value
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Value.Value
instance GHC.Read.Read Jikka.RestrictedPython.Language.Value.Local
instance GHC.Show.Show Jikka.RestrictedPython.Language.Value.Local
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Value.Local
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Value.Local
instance GHC.Read.Read Jikka.RestrictedPython.Language.Value.Global
instance GHC.Show.Show Jikka.RestrictedPython.Language.Value.Global
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Value.Global
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Value.Global

module Jikka.RestrictedPython.Language.VariableAnalysis
newtype ReadList
ReadList :: [VarName] -> ReadList
newtype WriteList
WriteList :: [VarName] -> WriteList
haveWriteReadIntersection :: WriteList -> ReadList -> Bool
analyzeExpr :: Expr' -> ReadList
analyzeTargetRead :: Target' -> ReadList
analyzeTargetWrite :: Target' -> WriteList
analyzeStatementGeneric :: Bool -> Statement -> (ReadList, WriteList)
analyzeStatementsGeneric :: Bool -> [Statement] -> (ReadList, WriteList)

-- | <a>analyzeStatementMax</a> returns lists of variables which are
--   possibly read or written in given statements.
analyzeStatementMax :: Statement -> (ReadList, WriteList)
analyzeStatementsMax :: [Statement] -> (ReadList, WriteList)

-- | <a>analyzeStatementMin</a> returns lists of variables which are always
--   read or written in given statements.
analyzeStatementMin :: Statement -> (ReadList, WriteList)
analyzeStatementsMin :: [Statement] -> (ReadList, WriteList)
instance GHC.Read.Read Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Show.Show Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Read.Read Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Show.Show Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.VariableAnalysis.WriteList

module Jikka.RestrictedPython.Language.Lint
makeEnsureProgram :: MonadError Error m => (Program -> Bool) -> String -> Program -> m ()

-- | <a>hasSubscriptionInLoopCounters</a> checks that there are
--   <a>SubscriptTrg</a> in loop counters of for-loops. This includes loop
--   counters of <a>ListComp</a>. For example, the followings has such
--   subscriptions.
--   
--   <pre>
--   for a[0] in range(100):
--       pass
--   return a[0]  # =&gt; 99
--   </pre>
--   
--   <pre>
--   a = [0]
--   b = [0 for a[0] in range(100)]
--   return a[0]  # =&gt; 99
--   </pre>
--   
--   NOTE: This is allowd in the standard Python.
hasSubscriptionInLoopCounters :: Program -> Bool
doesntHaveSubscriptionInLoopCounters :: Program -> Bool
ensureDoesntHaveSubscriptionInLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasLeakOfLoopCounters</a> checks that there are leaks of loop
--   counters of for-loops. For example, the following has a leak.
--   
--   <pre>
--   for i in range(100):
--       pass
--   return i  # =&gt; 100
--   </pre>
hasLeakOfLoopCounters :: Program -> Bool
doesntHaveLeakOfLoopCounters :: Program -> Bool
ensureDoesntHaveLeakOfLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasAssignmentToLoopCounters</a> checks that there are assignments
--   to loop counters of for-loops. For example, the following has the
--   assignment.
--   
--   <pre>
--   for i in range(100):
--       i += 1
--   </pre>
hasAssignmentToLoopCounters :: Program -> Bool
doesntHaveAssignmentToLoopCounters :: Program -> Bool
ensureDoesntHaveAssignmentToLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasAssignmentToLoopIterators</a> checks that there are assignments
--   to loop iterators of for-loops. For example, the followings have the
--   assignments.
--   
--   <pre>
--   a = list(range(10))
--   for i in a:
--       a[5] = i
--   </pre>
--   
--   <pre>
--   a = 0
--   for i in f(a):
--       a += i
--   </pre>
hasAssignmentToLoopIterators :: Program -> Bool
doesntHaveAssignmentToLoopIterators :: Program -> Bool
ensureDoesntHaveAssignmentToLoopIterators :: MonadError Error m => Program -> m ()

-- | <a>hasReturnInLoops</a> checks that there are return-statements in
--   for-loops. For example, the following has such a return-statement.
--   
--   <pre>
--   a = list(range(10))
--   for i in a:
--       return True
--   </pre>
hasReturnInLoops :: Program -> Bool
doesntHaveReturnInLoops :: Program -> Bool
ensureDoesntHaveReturnInLoops :: MonadError Error m => Program -> m ()

-- | <a>hasMixedAssignment</a> checks that there are assignments which
--   assign to both of bare variables and subscripted variables. For
--   example, the following is such an assignment.
--   
--   <pre>
--   a, b[0] = list(range(10))
--   </pre>
--   
--   NOTE: this doesn't check loop counters of <a>For</a> or
--   <a>ListComp</a>.
hasMixedAssignment :: Program -> Bool
doesntHaveMixedAssignment :: Program -> Bool
ensureDoesntHaveMixedAssignment :: MonadError Error m => Program -> m ()

-- | <a>hasNonTrivialSubscriptedAssignmentInForLoops</a> checks that there
--   are assignments with non-trivial subscriptions in for-loops. A trivial
--   subscription is a sequence of subscriptions to a variable with
--   constant indices and at most one trivial loop-counter indices for each
--   loops. A constant index is an expr which has a constant value in the
--   loop. A trivial loop-counter index is the loop counter from
--   "range(n)", "range(n, m)" or "enumerate(a)" with optional
--   post-addition with a positive int literal.
--   
--   For example, the followings have such assignments.
--   
--   <pre>
--   x = 0
--   for i in range(10):
--       x += 1
--       a[x] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       j = i
--       a[j] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[2 * i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[1 + i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i - 1] += 1
--   </pre>
--   
--   <pre>
--   c = 1
--   for i in range(10):
--       a[i + c] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i][i] += 1
--   </pre>
--   
--   <pre>
--   for i in [1, 2, 3]:
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   b = range(10)
--   for i in b:
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(0, 10, 2):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i, b_i in enumerate(b):
--       a[b_i] += i
--   </pre>
--   
--   For example, the followings don't have such assignments.
--   
--   <pre>
--   c = 0
--   for i in range(10):
--       a[c] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i + 1] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       for j in range(10):
--           a[i + 1][j] += 1
--   </pre>
--   
--   <pre>
--   for i in range(1, 10):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i, b_i in enumerate(b):
--       a[i] += b_i
--   </pre>
hasNonTrivialSubscriptedAssignmentInForLoops :: Program -> Bool
doesntHaveNonTrivialSubscriptedAssignmentInForLoops :: Program -> Bool
ensureDoesntHaveNonTrivialSubscriptedAssignmentInForLoops :: MonadError Error m => Program -> m ()

-- | <tt>hasAssginmentToBuiltin</tt> checks that there are assignments to
--   builtin functions. For example, the followings have such assignments.
--   
--   <pre>
--   map = 3
--   </pre>
--   
--   <pre>
--   return [range for range in range(10)]
--   </pre>
hasAssignmentToBuiltin :: Program -> Bool
doesntHaveAssignmentToBuiltin :: Program -> Bool
ensureDoesntHaveAssignmentToBuiltin :: MonadError Error m => Program -> m ()

-- | <a>hasNonResolvedBuiltin</a> checks that there are not resolved
--   builtin functions. This always doesn't hold after
--   <a>ResolveBuiltin</a>.
hasNonResolvedBuiltin :: Program -> Bool
doesntHaveNonResolvedBuiltin :: Program -> Bool
ensureDoesntHaveNonResolvedBuiltin :: MonadError Error m => Program -> m ()


module Jikka.RestrictedPython.Evaluate
run :: MonadError Error m => Program -> Expr' -> m Value

-- | <a>makeGlobal</a> packs toplevel definitions into <a>Global</a>. This
--   assumes <a>doesntHaveLeakOfLoopCounters</a>.
makeGlobal :: MonadError Error m => Program -> m Global
runWithGlobal :: MonadError Error m => Global -> Expr' -> m Value

-- | <a>evalExpr</a> evaluates exprs of our restricted Python-like
--   language.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt; &lt;math&gt; &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt; &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
evalExpr :: (MonadReader Global m, MonadState Local m, MonadError Error m) => Expr' -> m Value

-- | <a>evalStatement</a> evaluates statements of our restricted
--   Python-like language. When a statement is evaluated, it returns a
--   value &lt;math&gt;, doesn't return anything &lt;math&gt;, or fails
--   &lt;math&gt;. Also it updates the environment function &lt;math&gt;
--   from variables to values.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   It assumes the program is properly alpha-converted, i.e.
--   <a>doesntHaveLeakOfLoopCounters</a>. So it leaks loop counters to out
--   of loops.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
evalStatement :: (MonadReader Global m, MonadState Local m, MonadError Error m) => Statement -> m (Maybe Value)

-- | <a>evalStatements</a> evaluates sequences of statements of our
--   restricted Python-like language.
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
evalStatements :: (MonadReader Global m, MonadState Local m, MonadError Error m) => [Statement] -> m (Maybe Value)
execToplevelStatement :: (MonadState Global m, MonadError Error m) => ToplevelStatement -> m ()

module Jikka.RestrictedPython.Convert.ResolveBuiltin

-- | <a>run</a> resolves types of polymorphic builtin functions. This
--   assumes there are no assignments to builtin functions, i.e.
--   <a>doesntHaveAssignmentToBuiltin</a>.
--   
--   For example, the <tt>max</tt> of <tt>max(xs)</tt> has a type
--   &lt;math&gt; but the <tt>max</tt> of <tt>max(x, y, z)</tt> has a type
--   &lt;math&gt;. So this function converts <tt>Var "max"</tt> to
--   <tt>BuiltinMax1 t</tt>, <tt>BuiltinMax t 2</tt>, <tt>BuiltinMax t
--   3</tt>, etc..
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.RestrictedPython.Convert.ToCore

-- | <a>run</a> converts programs of our restricted Python-like language to
--   programs of our core language. This assumes the follwing conditions:
--   
--   <ul>
--   <li><a>doesntHaveSubscriptionInLoopCounters</a></li>
--   <li><a>doesntHaveLeakOfLoopCounters</a></li>
--   <li><a>doesntHaveAssignmentToLoopCounters</a></li>
--   <li><a>doesntHaveAssignmentToLoopIterators</a></li>
--   <li><a>doesntHaveReturnInLoops</a></li>
--   <li><a>doesntHaveNonTrivialSubscriptedAssignmentInForLoops</a></li>
--   </ul>
--   
--   For example, this converts the following:
--   
--   <pre>
--   def solve(n):
--       if n == 0:
--           return 1
--       else:
--           return n * solve(n - 1)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let solve n =
--       if n == 0 then
--           1
--       else:
--           n * solve (n - 1)
--   in solve
--   </pre>
--   
--   Also, this converts the following:
--   
--   <pre>
--   def solve(n):
--       a = 0
--       b = 1
--       for _ in range(n):
--           c = a + b
--           a = b
--           b = c
--       return a
--   </pre>
--   
--   to:
--   
--   <pre>
--   let solve n =
--       fst (foldl (fun (a, b) i -&gt; (b, a + b)) (0, 1) [0 .. n - 1])
--   in solve
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | <a>runForStatement</a> converts for-loops to <a>foldl</a>. For
--   example, this converts the following:
--   
--   <pre>
--   # a, b are defined
--   for _ in range(n):
--       c = a + b
--       a = b
--       b = c
--   ...
--   </pre>
--   
--   to:
--   
--   <pre>
--   let (a, b) = foldl (fun (a, b) i -&gt; (b, a + b)) (a, b) (range n)
--   in ...
--   </pre>
runForStatement :: (MonadState Env m, MonadAlpha m, MonadError Error m) => Target' -> Expr' -> [Statement] -> [Statement] -> [[Statement]] -> m Expr

-- | <a>runIfStatement</a> converts if-loops to if-exprs.
--   
--   <pre>
--   # a, b are defined
--   if True:
--       a = 0
--       b = 1
--       c = 3
--   else:
--       a = 1
--       c = 10
--   ...
--   </pre>
--   
--   to:
--   
--   <pre>
--   let (a, c) = if true then (0, 3) else (1, 10)
--   in ...
--   </pre>
runIfStatement :: (MonadState Env m, MonadAlpha m, MonadError Error m) => Expr' -> [Statement] -> [Statement] -> [Statement] -> [[Statement]] -> m Expr

module Jikka.RestrictedPython.Convert.Alpha

-- | <a>run</a> renames variables. This assumes
--   <a>doesntHaveAssignmentToBuiltin</a>.
--   
--   <ul>
--   <li>This introduce a new name for each assignment if possible. For
--   example, the following</li>
--   </ul>
--   
--   <pre>
--   x = 21
--   x += x
--   x = 42
--   x += x
--   for _ in range(100):
--       x = x + 1
--   x = x + 1
--   </pre>
--   
--   turns the following
--   
--   <pre>
--   x0 = 21
--   x1 += x0
--   x2 = 42
--   x3 += x2
--   for a4 in range(100):
--       x3 = x3 + 1
--   x5 = x3 + 1
--   </pre>
--   
--   <ul>
--   <li>This blames leaks of loop counters of for-statements, i.e.
--   <a>doesntHaveLeakOfLoopCounters</a>. For example, the followings is
--   not allowed.</li>
--   </ul>
--   
--   <pre>
--   for i in range(10):
--       a = 0
--   return a  # error
--   </pre>
--   
--   <ul>
--   <li>This blames leaks of names from for-statements and if-statements
--   at all. For example, the followings are not allowed.</li>
--   </ul>
--   
--   <pre>
--   if True:
--       a = 0
--   else:
--       b = 1
--   return a  # error
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a = 0
--   return a  # error
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
instance GHC.Show.Show Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Read.Read Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Classes.Ord Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Classes.Eq Jikka.RestrictedPython.Convert.Alpha.Env

module Jikka.RestrictedPython.Convert.SplitLoops

-- | <a>run</a> does alpha conversion, check assumptions, and <a>run</a>`.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | <a>run</a>` splits for-loops into many small for-loops as possible.
--   This assumes that <a>doesntHaveSubscriptionInLoopCounters</a>,
--   <a>doesntHaveAssignmentToLoopCounters</a>, and
--   <a>doesntHaveAssignmentToLoopIterators</a> hold. This may introduce
--   name conflicts.
--   
--   For example, the following
--   
--   <pre>
--   a = 0
--   b = 0
--   for i in range(10):
--       c = b
--       a += i
--       b += c
--   </pre>
--   
--   is split to
--   
--   <pre>
--   a = 0
--   b = 0
--   for i in range(10):
--       c = b
--       b += c
--   for i in range(10):
--       a += i
--   </pre>
run' :: Program -> Program

-- | <a>runForLoop</a> splits a for-loop to many for-loops as possible.
--   This assumes that <a>doesntHaveSubscriptionInLoopCounters</a>,
--   <a>doesntHaveAssignmentToLoopCounters</a>, and
--   <a>doesntHaveAssignmentToLoopIterators</a> hold.
--   
--   This function analyzes read-variables and write-variables in
--   statements, and split statements into connected components.
runForLoop :: Target' -> Expr' -> [Statement] -> [Statement]

module Jikka.RestrictedPython.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
run' :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Main.Subcommand.Execute
run :: Target -> FilePath -> ExceptT Error IO ()

module Jikka.Main.Subcommand.Debug
run :: FilePath -> ExceptT Error IO ()

module Jikka.Main.Subcommand.Convert
run :: Target -> FilePath -> Text -> Either Error Text

module Jikka.RestrictedPython.Language.WithoutLoc
constIntExp :: Integer -> Expr'
constBoolExp :: Bool -> Expr'
constBuiltinExp :: Builtin -> Expr'
binOp :: Expr' -> Operator -> Expr' -> Expr'
addExp :: Expr' -> Expr' -> Expr'
subExp :: Expr' -> Expr' -> Expr'
multExp :: Expr' -> Expr' -> Expr'
unaryOp :: UnaryOp -> Expr' -> Expr'
eqExp :: Type -> Expr' -> Expr' -> Expr'
name :: VarName' -> Expr'
call :: Expr' -> [Expr'] -> Expr'
list :: Type -> [Expr'] -> Expr'
listComp :: Expr' -> Comprehension -> Expr'
subscript :: Expr' -> Expr' -> Expr'
nameTrg :: VarName' -> Target'
subscriptTrg :: Target' -> Expr' -> Target'
tupleTrg :: [Target'] -> Target'

module Jikka.Main
data Flag
Help :: Flag
Verbose :: Flag
Version :: Flag
Target :: String -> Flag
data Options
Options :: Bool -> Maybe Target -> Options
[verbose] :: Options -> Bool
[target] :: Options -> Maybe Target
defaultOptions :: Options
header :: String -> String
options :: [OptDescr Flag]
main :: String -> [String] -> IO ExitCode
parseFlags :: String -> [Flag] -> Either Error Options
runSubcommand :: String -> Options -> FilePath -> ExceptT Error IO ()
instance GHC.Read.Read Jikka.Main.Flag
instance GHC.Show.Show Jikka.Main.Flag
instance GHC.Classes.Ord Jikka.Main.Flag
instance GHC.Classes.Eq Jikka.Main.Flag
instance GHC.Read.Read Jikka.Main.Options
instance GHC.Show.Show Jikka.Main.Options
instance GHC.Classes.Ord Jikka.Main.Options
instance GHC.Classes.Eq Jikka.Main.Options
