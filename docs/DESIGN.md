# Design Doc

## Objective

Jikka は、競技プログラミングの問題を解く行為そのものを自動化するツールである。
特にこれを「最適化を伴うトランスパイラ」の形に落とし込んで実現する。

## Goals

- 形式的な形で与えられた競技プログラミングの問題の解法を自動で生成すること。またこれによりユーザのレートを上げること
- 競技プログラミングにおける機械的に処理できる部分を機械的に処理することによって、機械的には処理できないより本質的でおもしろい部分に人間が集中できるようにすること

## Non-Goals

- 自然言語で与えられた競技プログラミングの問題の解法を自動で生成すること
- 競技プログラミングにおける機械的に処理できる部分を機械的に処理することによって、競技プログラミングのおもしろさを破壊すること

## Background

競技プログラミングの問題の中には、機械的に解けるであろう問題が存在する。
全体が機械的に解けるということはない場合であっても、部分的になら機械的に解けるであろう問題は多い。
たとえば、個々の式変形それ自体は自明な式変形を丁寧に行っていくことで解けるような問題である。これを自動化したい。

## Overview

Jikka はその概観としてはただのトランスパイラである。
Python のとても制限されたサブセットとして書かれたソースコードを受けとり、GHC の Core に似た内部言語の上で最適化を行い、最終的に C++ のソースコードを出力する。

## Detailed Design

### 競技プログラミングの問題を解く過程は「形式化」「考察」「実装」に分けられる

競技プログラミングの問題を解く過程は以下の 3 ステップに大別できる。

1.  形式化: 自然言語で与えられた問題を解釈し、数学的で形式的な問題として整理する
2.  考察: 数学的で形式的な問題に対し、数学的で抽象的な解法を考案する
3.  実装: 数学的で抽象的な解法を、計算機における具体的な実装として記述する

競技プログラミングの (すくなくとも AtCoder で出題されるような問題の) 中心であり最もおもしろくかつ難しい部分は「考察」の部分であると考えられている。
しかしこの「考察」にも、一定の知識があれば機械的に可能であるような部分は多く含まれている。
Jikka はそのような機械的な考察を処理する。

このような「考察の自動化」について考察は [docs/how-it-works.pdf](https://github.com/kmyk/Jikka/blob/master/docs/how-it-works.pdf) により詳しい説明がある。

### 「考察」の自動化を実現する方法は「エキスパートシステム」「自動定理証明器」「コンパイラ」などに分けられるだろう

競技プログラミングの問題を自動で (あるいは半自動で) 解くソルバを作りたいと考えたとき、仕様や設計の選択肢の方向は大きく分けて次のみっつであろう:

1.  エキスパートシステム / DSL 処理系 / データベース / etc. (例: WolframAlpha, PostgreSQL, OEIS, GLPK, Z3, Akinator, ...)
2.  自動定理証明器 / 定理証明支援系 (例: Otter, Coq, Agda, ...)
3.  コンパイラ / トランスパイラ (例: Haskell, F#, Rust, ...)

(1.) は最も直接的なものである。このような方向のソルバは「形式的に書かれた競プロの問題を入力とし、解法コードを出力する」ものだろう。
問題を直接形式化したかなり高級な表現を受けとることになるはずである。
たとえば [AtCoder Regular Contest 066: D - Xor Sum](https://atcoder.jp/contests/arc066/tasks/arc066_b) であれば `given N: int; assume: 1 <= N <= 10^18; count (u, v): int * int s.t. 0 <= u <= N, 0 <= v <= N, (exists (a, b): int * int. a xor b = u /\ a + b = v);` のような入力になるかもしれない。
(1.) の方向のソルバであって (2.) や (3.) から遠いものを考えると、性質のよい問題のクラスに対する個別のソルバの集合体としてのソルバや、問題とその解法のデータベースシステムという形になるだろうと思われる。

(2.) は理論的に整理したものである。このような方向のソルバは「計算可能関数のある表現を入力とし、その関数のよい計算量についての構成的証明を出力する」ものである。
高度な考察を自動で行いたいと思うと、(2.) の方向のソルバも最終的にはこれに近づくものと予想している。

(3.) は最も現実的なものである。このような方向のソルバは「通常のプログラミング言語のソースコードを入力とし、計算量的な最適化がなされた機械語やその他の言語のソースコードを出力とする」ようなものである。
実装においても利用においても簡単であることが利点となる。

また、上記の (1.), (2.), (3.) とは別に、個別の問題のクラス (線形計画問題, 制約充足問題, ...) に対するソルバがそれぞれ作られることもあるだろう。
そのようなソルバの解ける問題の範囲はかなり限られたものとなる。
しかし個別の問題に対するソルバは理解しやすいという点で優れている。つまり、「ある問題を解くことができるかできないか」「得られる解法はどのような性質を持つか」などが分かりやすく、扱いやすい。

### トランスパイラとして実装される

トランスパイラとして実装される
開発と利用が簡単であるためである。
目標が壮大すぎて最初から完璧なものを作るのは不可能であるため、まずは確実に実装可能な部分から始めていくのがよいだろう。

### 入力言語には Python を用いる

以下の 2 点を理由として、入力言語には Python のサブセットを用いる。

1.  利用しやすい: 学習しやすく、書きやすい。Python は広く普及していてかつそこそこ高級な言語である
2.  開発しやすい: 言語機能を制限すればコンパイラで扱いやすい。本物の Python との差分は未定義動作という形で吸収すればよい

言語機能は大きく制限し、静的型付け言語とする。
副作用はある種の糖衣構文としてのみ残し、意味論的には存在しない。

### 入力言語に独自の新しいプログラミング言語を用いることはしない

以下の 2 点を理由として、入力言語に独自言語を用いることは避ける。
それぞれ Python を用いる理由の裏となっている。

1.  利用しにくい: 独自言語であると、ユーザはその言語を新規に覚える必要がある。たいていのユーザにとって新しい言語を覚えることはかなりの負担である
2.  開発しにくい: 独自言語であると、開発者はその言語のドキュメントを丁寧に書く必要がある。仕様が明確であることや解説が豊富にあることはプログラミング言語の重要な機能性のひとつである

### 出力言語には C++ を用いる

理由は以下の 2 点である。

1.  利用しやすい: 競プロという用途において柔軟な利用が可能になる
2.  開発しやすい: 局所的な最適化をまったく回避できる

## Metrics Considerations

適切な仮定の下で「AtCoder 上でのレート」という形で性能評価が可能である。
また「AtCoder Beginner Contest などの問題のうち何割が解ける」などの形での評価も可能だろう。

## Testing Plan

効率良く実行できる安定した end-to-end テストが簡単に書けるため、これを利用するのがよいだろう。
つまり、俗に「verify する」と呼ばれる、実際の競技プログラミングの問題に対して利用して AC を確認するという形式のテストに類似したものが可能である。

## 先行事例

競技プログラミングでの利用を意図したものに限れば、以下のような先行事例がある。

- 個別の問題のソルバとしては [wata](https://atcoder.jp/users/wata) による「Σ 電卓」が知られている ([wata-orz/SigmaCalculator](https://github.com/wata-orz/SigmaCalculator), [Σ 電卓 - てきとーな日記](https://wata-orz.hatenadiary.org/entry/20091223/1261582436)) (2009 年)。
- 実装には至っておらず構想のみであるが、一般の問題の解法の自動生成についての試みが [kinaba](https://www.topcoder.com/members/cafelier/) によってなされている ([SRM 531 Div2 250 - cafelier@SRM - TopCoder 部](https://topcoder-g-hatena-ne-jp.jag-icpc.org/cafelier/20120204/1328332594.html) など) (2012 年)。
- AtCoder Beginner Contest のある A 問題の解法の完全自動生成が [mkotha](https://atcoder.jp/users/mkotha) によって行われたことがある (<https://twitter.com/atcoder/status/538665089931296768>, <https://atcoder.jp/contests/arc030/submissions/286413>) (2014 年)。
- 最適化などは含まれていないが、競技プログラミングでの利用を意図して作られた言語としては [laycurse](https://atcoder.jp/users/LayCurse) による cLay がある ([cLay 概要（version 20201123-1） - ゲームにっき（仮）別館（仮）](http://rsujskf.s602.xrea.com/?cLay)) (2107 年から)。
